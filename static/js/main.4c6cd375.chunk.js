(this["webpackJsonplearn-scilla"]=this["webpackJsonplearn-scilla"]||[]).push([[0],{103:function(e,n,t){"use strict";t.r(n);var a=t(0),s=t.n(a),i=t(49),r=t.n(i),o=t(26),l=t(14),d=t(41),c=t(51),m=t.n(c),h=[{title:"Elementary",lessons:["\n## Introduction\n\nHello, in this guide you will learn about how to develop smart contracts and applications that use them for the NEO blockchain, we will do that by building a game of collectible pepes where users can:\n- Claim pepes\n- Trade pepes\n- Award Good Boy Points to their pepes\n\nOn this first chapter we will create our first smart contract pepe, complete with good boy point functionality. Let's start!\n\n## Lesson 1: Contract declaration\n\n**Declaring a contract:**\n\nFirst of all, currently most smart contracts on Neo are written using C#. In case you have no experience with it, don't worry! This guide assumes no previous knowledge of C# and will teach C# and smart contracts together. For now the only thing that matters is that in order to start doing smart contract magic we'll need to include some libraries from Neo:\n\n```\nusing Neo.SmartContract.Framework;\nusing Neo.SmartContract.Framework.Services.Neo;\n```\n\nNow, we can start with the main part of the smart contract coding. The contract that you\u2019ll be deploying to the blockchain has to have a name by which it could later be identified. We will also put it inside the Neo namespace to make things easier.\nWe will do that with the following lines: \n\n\n```\nnamespace Neo.SmartContract\n{\n    public class ContractName : Framework.SmartContract\n\t{\n\t}\n}\n```\n\nWhere you replace the `ContractName` with the actual name for your contract.\n\nYou can safely ignore all the keywords such as `namespace`, `public` and `class`. These are features of C# which are not relevant here.\n\n## Task\n\n1. Begin your smart contract with the library inclusions shown above. \n2. Then, in next line, declare a contract which should be called `NeoPepes`.\n\n\n\n","\n## Lesson 2: Immutable variables\n\nAny contract deployed on the blockchain is immutable. In other words, that code can\u2019t be changed. This is one of the main reasons why security of smart contracts is a fundamental concern from the very start of the coding stage, or perhaps even before that.\n\nNow, while deploying the contract on the blockchain, you can also initiate certain parameters. Once initialized, the values of these parameters won\u2019t change, i.e. the values of these variables can\u2019t be changed later. They are called immutable variables. \n\nFor instance, when somebody finally deploys a contract code on the blockchain, their wallet address is also passed along with the code. It\u2019s often useful to store this address as an immutable variable because wallet addresses can serve as an identity, just like unique email addresses. But instead of sending and receiving emails, wallet addresses are primarily used for sending and receiving digital assets. You may want to store a wallet address as the address of the contract\u2019s owner to uniquely identify the owner and grant her different access rights if required. \n\nYou can then use this immutable variable that stores the owner\u2019s wallet address as a check, so that certain operations in the contract can only be carried out by the owner. The important part about storing the address as an immutable variable is that by doing this, the address of the owner can\u2019t be changed by a third party. (Or else, there\u2019s a possibility that a hacker might be able to change the owner address to her own wallet address and then act maliciously as the new owner) \n\nTo declare an immutable variable, we need to pay attention to two factors:- \n\nVariable name: This is the identifier of the variable to be used by various operators later in the contract. \n\nVariable type: Variable types represent the kind of data stored in the variable, such as text or numbers etc. We\u2019ll discuss variable types in more detail shortly.\n\nThe format for specifying an immutable variable is: \n\n```\ncontract ContractName\n(variablename1 : variabletype1)\n```\nWhere `variablename1` and `variabletype1` can be replaced by the chosen variable name and type.\n\nFor e.g. ,\n```\ncontract  Example123 (var1 : ByStr20)\n```\n\n\nIf there are multiple immutable variables, then you can include them as follows:\n```\ncontract ContractName\n(\n    variablename1 : variabletype1,\n    variablename2 : variabletype2,\n    variablename3 : variabletype3\n)\n```\n\nFor e.g.,\n```\ncontract  Example123 (a: Uint128, b: String)\n```\n\n\nHere, multiple immutable variables are declared by separating them with commas.\nThe language supports several datatypes, such as  `Int32` (to represent 32-bit integers),\n`ByStr20` ( a sequence of hexadecimal characters that represents 20 bytes. This data type is most convenient to store wallet addresses and will be often used in smart contracts).\nA detailed list can be seen in the cheat sheet in the left bottom corner of the website. \n\nThere are many such data types in Scilla with different types of declaration and that is intentional so that later automated checks on the program can be run more easily.\n\nAs Robin Milner once said: *\"Well typed programs don\u2019t go wrong\"*\n\nWe\u2019ll only be introducing some of the data types through these tutorials.\nFor a detailed list of all the types, kindly refer to the 'cheat sheet' in the navigation menu above.\n\n## Task\n\nIn our last exercise, we had declared a contract called `SocialMediaPayment`. It should have one immutable variable with the name `owner` and the variable should be of type `ByStr20`.\n\n\n",'\n## Lesson 3: Mutable variables\n\nA smart contract is not much different from a regular program. It takes certain inputs, operates on them and returns an output. Any operation may also require reading other data from the memory or storage.\n\nFor doing operations on data, we usually need to have variables whose value will be changed by the code in the contract. \n\nThese variables, which can be updated but are still stored on the blockchain are known as mutable variables. \n\nAt this point, new students often ask how you can store something mutable on an immutable blockchain. The answer is that what remains immutable is the history of how that variable\u2019s value changed over the time. But only the latest value is actually considered by the contract to be the true value of the variable. \n\nFor e.g. , If you had USD 100 at the beginning of the month and spent USD 40 by the end of it then the bank will have a clear transaction history which you can\u2019t change even though you can certainly change your current balance by depositing or withdrawing more money. In this example your current balance is a mutable variable but the balance-sheet itself is immutable. \n\nTo declare a mutable variable, we need to pay attention to three factors:-\nVariable name: This is the identifier of the variable to be used by various operators later in the contract.\nVariable type: Choose the appropriate type of the variable. Such as `Uint128` for amounts, String for names, `ByStr20` for addresses etc.\nVariable value: We may choose to declare a variable with or without an initial value.\n\nThe format for the mutable variable declaration might slightly vary depending on the variable type and variable value. You can access the list of the most important permutations in the variable declarations in the Cheat Sheet given in bottom left corner of this page. For now, let\u2019s look at the format for a simple mutable variable that will contain a text/string value.\n\n\n```\nfield variableName : variableType = "Variable Text"\n```\n\nThe VariableType is \u2018String\u2019 in the current case. \n\nEg.\n```\nfield a : String = "hello"\n```\n\nThe important point to know is that in the smart contract security, changing the value of a mutable variable is a very important step and if done wrong, such a change could inadvertently result in major security vulnerabilities. We\u2019ll see later how that issue can be handled in a methodical way in Scilla. \n\n\n## Task\n\nLet\u2019s start with having a simple variable that stores the name of a user.\nDeclare a variable with following details:\n* Variable name: `username`\n* Variable type: `String`\n* Variable value: `Alice`\n','\n## Lesson 4: Transition\n\nThe smart contract code on blockchain needs to be able to interact with the external world for the contract to be actually useful; in other words it needs some interfaces so that the commands, data or tokens can be sent to the smart contract or be requested from it. \nThis is achieved by having transitions in the smart contract. \nTransitions are similar to \u2018functions\u2019 or \u2018methods\u2019 in other languages.\nA transition is declared using the keyword \u2018transition\u2019. The end of a transition scope is declared using the keyword \u2018end\u2019. The transition keyword is followed by the transition name. Then follows the input parameters within (). Each input parameter is separated by a comma and is declared in the following format: variablename : variabletype\n\n\nThe format is:\n```\ntransition transitionName (variablename : variabletype)\n\nend\n```\nExample:\n```\ntransition setHello (msg : String)\nend\n```\nIn order to use a smart contract, a transition within the smart contract will have to be called.\nIt can be called directly or by another program or smart contract.\n\n## Task\n\nSo far, we have a fixed value for our username variable, which is "Alice".\nLet\u2019s have an option that the name could be changed. To change a mutable variable, we\u2019ll need a transition.\n\nDeclare a transition with the name `changeName`.\nYou don\u2019t need to pass any variables to it right now, so the brackets after the name will be empty.\n\nThere will be no code in the body of the transition at the moment.\nWe\u2019ll fill it in later. For now, just declare an empty transition named `changeName`,\nand close it by using the keyword `end`\n','\n## Lesson 5: Variable declaration in a transition\n\nWe can also declare variables within a transition. \nDo note that these variables are not immutable variables nor are they mutable variables like the ones we learned about earlier even though the values of these variables that exist within a transition can also be changed. This is because their value is never stored on the blockchain. Rather they are temporary variables whose scope is limited within the transition for the duration of that single call. \n\nThe temporary variable declaration format is different from the format in which the mutable variables are declared. For instance, a String variable is declared in the following format:\n```\nvaribaleName = "value"\n```\nExample:\n```\na = "hello"\n```\n\n**Note:**\nIn a transition, if there are multiple lines, then they are separated by `semicolons`.\nLet\u2019s take a look at an example of a transition with two variables declared in it:\n\nExample:\n```\ntransition foo()\n    a= "hello";\n    b= Int32 5\nend\n```\nIn this example, we declare two variables in a transition named "foo".\nThe first variable is a string type variable that stores the value hello.\nThe second variable is an integer type variable that stores the value 5.\n\nNotice two points in this example: \nThe two lines within the transition are separated by a single semicolon. We don\u2019t use a semicolon after the declaration of the variable \u201cb\u201d because there are no further lines in the transition seen in the example. Those who\u2019re familiar with other computer languages might be used to using a semicolon to end a line of code. However, here the semicolon can be thought of as being used in the capacity of a conjunction rather than a period, so just like we won\u2019t normally use the conjunction \u2018and\u2019 at the end of a sentence, similarly we don\u2019t use the semicolon here at the end but instead to join the various lines. \nThe format of the declaration of a string variable is different from the format of declaration of an integer variable. You can find the full list of the declaration format of all the major variable types (in the main body of the contract, and in the transition) in the \u2018Cheat Sheet\u2019 given at the bottom left corner of this page.\n\tHowever, for the sake of the exercise at the hand, you can just refer to the content provided in this lesson. \n\n\n## Task\n\nWe want to replace the original user name declared in mutable variable `username` in this transition. To do that, we will need a new name.\n\nDeclare a new variable with the name `newname` and type `String` and give it a value `Bob`.\n\n',"\n## Lesson 6: Changing a mutable field\n\nAs stated earlier, the variable declared in the transition is a temporary variable that isn\u2019t stored on the blockchain and exists only while the contract is being run.\nWe can use these temporary variables to get values from the user input, mutable variables etc. and then we can perform operations on these values. Then, in order to ensure that blockchain contains the final value, it has to be transferred to a mutable variable. \nYou\u2019ll note that the design of Scilla language is making a user be very cautious about updating any value assigned to a mutable variable. That is so because changing a mutable variable is a critical operation and if done in a wrong manner, it could lead to security issues.\nWe\u2019ll explore this in more detail in later chapters. At the moment, we simply need to assign the value of the temporary variable to the mutable variable. \nThe format of such an assignment is: \n\n```\nMutableVariableName := TemporaryVariableName\n```\nExample:\n```\nmutvar1 := tempvar1\n```\n\n## Task\n\nUpdate the mutable variable `username` with the value of the temporary variable `newname` in the body of the transition.\n\n","\n## Lesson 7: Getting values\n\nYou\u2019ll notice the issue with the previous lesson that the new user is always changed to a fixed value each time that the transition is called. Ideally, we\u2019ll like to have options other than \u201cBob\u201d about the new name which is updated. This can be done by letting the user pass on a value to the transition whenever she\u2019s calling it. \nSimilar to how we could have passed variables to the contract while creating it, we could also pass variables to a transition while calling it. \nThe format for declaring these temporary variables that have to be sent by a user when she calls the transition is as follows: \n\n```\ntransition transitionName (parameterName_1 : parameterType_1)\n\n  \nend\n```\n\n\nIn case we want to declare multiple variables here, then we can do so by separating the variable name and variable types by commas, as shown below:\n```\ntransition transitionName (parameterName_1 : parameterType_1, parameterName_2 : parameterType_2, parameterName_3 : parameterType_3)\n  \nend\n```\nExample:\n```\nTransition foo (\n    var1: String,\n    var2: Int32,\n    var3 Uint32\n)\nend\n```\n\n## Task\n\nWe want to change the name of the user \u2018Alice\u2019 that we\u2019ve earlier stored in the mutable variable \u2018username\u2019. To do this, we created the transition \u2018changeName\u2019 and assigned a value to \u2018username\u2019. In order to make the change more flexible, we\u2019ll also need the new name each time the transition is called. So, we\u2019ll delete the old variable declaration in the body of the transition. Now do the following: \n \nInclude the parameter with name \u201cnewname\u201d and variable type \u201cString\u201d in the declaration of the transition so that a user has to send a new name for the user each time she wishes to change the old value.  \n\n","\n## Lesson 8: Implicit variables\n\nIn addition to parameters that are explicitly declared in the definition, each transition also has the following implicit parameters available to it for each call:\n```\n_sender : ByStr20\n```\n\nThis variable contains the account address that triggered this transition. In case, the transition was called by a contract account instead of a user account, then _sender contains the contract address.\n\n\n```\n_amount : Uint128\n  ```\n\n\nThis contains the incoming amount (ZILs) sent by the sender. This amount *must be explicitly accepted using the `accept` statement within the transition*. The money transfer does not happen if the transition does not execute accept.\n\n\n## Task\n\n1. Declare two new mutable variables in the contract:\n* `user_address` of type `ByStr20` with value `0x1234567890123456789012345678901234567890`\n* `user_tokens` of type `Uint128` with value `0` in the contract.\n\n2. Then in the transition, assign these variables the value of `_sender` and `_amount` respectively.\n\n3. Remember that the implicit variable _amount has to be explicitly accepted. Use a simple \u2018accept\u2019 command in the first line of the transition \u2018changeName\u2019. \n\nAs mentioned earlier, you can refer to the variable declaration format of all types in the \u2018Cheat Sheet\u2019 given at the bottom left corner of this page.\n","\n## Lesson 9: Summary\n\nChapter Number and title: Summary\nLesson contents (includes the task at the end)\nCongrats!\nYou\u2019ve learned:\n* how to declare a new contract,\n* how to declare a new transition,\n* how to declare immutable variables,\n* how to declare mutable variables,\n* how to declare temporary variables in the transition,\n* how to use the implicit variables in a transition,\n* how to change the value of mutable variables in the transition.\n\nYou\u2019ve learned the general structure of a contract which looks like the following:\n(* Scilla contract structure *)\n\n```\n(***************************************************)\n(*               Associated library                *)\n(***************************************************)\n\nlibrary MyContractLib\n\n\n(* Library code block follows *)\n\n\n\n(***************************************************)\n(*             Contract definition                 *)\n(***************************************************)\n\ncontract MyContract\n\n(* Immutable fields declaration *)\n\n(vname_1 : vtype_1, vname_2 : vtype_2)\n\n(* Mutable fields declaration *)\n\nfield vname_1 : vtype_1 = init_val_1\nfield vname_2 : vtype_2 = init_val_2\n\n(* Transitions *)\n\n(* Transition signature *)\ntransition firstTransition (\n    param_1 : type_1,\n    param_2 : type_2\n)\n    (* Transition body *)\nend\n\ntransition secondTransition (param_1: type_1)\n    (* Transition body *)\nend\n```\n\nYou\u2019ve defined a user which has certain attributes such as name, address and tokens.\n\n\n"]},{title:"Intermediate - A",lessons:["\n## Lesson 1: Making a transition for depositing tokens\n\nIn the last chapter, we learned about various kinds of variables, including implicit variable. \nLet\u2019s build a transition that actually uses that. \nWe\u2019ll first wipe the variables from the first chapter, and from now onwards all the code that we\u2019ll be using will help us directly build the social media payment application that we discussed. \n\nFirst of all, in order to give ZIL tokens as rewards, the contract must have access to them. \nIn order to ensure that, we need to build a transition where the ZIL tokens can be deposited in the contract. \n\n\n\n## Task\n\n 1. Declare a `transition` with the name 'deposit\u2019. Make sure to close it with `end` keyword.\n\n","\n## Lesson 2: Boolean operations\n\nNow, we\u2019ve to ensure that this transition can accept any amount of ZILs sent to it. We\u2019ve already seen how to do this at the end of chapter 1. \nWe can simply repeat that process here and technically that\u2019s fine. \nHowever, for any actual application, you probably want to ensure that not everybody can send tokens to this transition. Can you think of a reason why you would deny getting an additional amount? \nWell, for one thing, it will make your auditing really difficult if you don\u2019t have a clear track of who\u2019s sending the tokens to your contract. Also, it\u2019s generally a good coding practice to manage access to transitions in a controlled manner. \nSo, we\u2019ll program this transition so that only the owner can send money to it. \n\nWe\u2019ve two variables: `owner` which is an immutable variable and will always remain constant and `_sender` which is an implicit variable and contains the wallet address of the user who has invoked the transition for that operation. We need to have a condition that ensures that deposit happens only when the two variables\u2019s values are the same. \n\nTo do this, we\u2019ll need to use comparison operators which are available in Scilla. These operators check whether the given comparison (such as, is a= b, or is a>b, or is a <b)  is true or false, and accordingly return a boolean (i.e. a value that is \u2018true\u2019 or \u2018false\u2019) value. \n\nIn order to process these boolean values, we will need to include a boolean library in our code. \n\nYou can do this by using import function for any library. \nThe format for that is:\n\n```\nimport LibraryName\n```\n\nE.g., \n```\nimport ListUtils\n```\n\nIf there are multiple libraries, then you can simply include more libraries by providing a space between their names after the keyword import\n\n```\nimport LibraryName1 LibraryName2\n```\n\nE.g.,\n```\nimport ListUtils IntUtils\n```\n\n\n\nNote: You have to use \u2018import\u2019  before the contract declaration. \n\n\nYou can find the complete list of libraries here: https://scilla.readthedocs.io/en/latest/scilla-in-depth.html?highlight=boolutils#standard-libraries\n\n\nFor now, we only need to include one library: BoolUtils\n\n\n\n\n## Task\n\n After the scilla version declaration and before the contract declaration, do the following:\n \n 1. Import the following library: `BoolUtils`. Use the keyword `import` to do so. \n\n\n","\n## Lesson 3: Builtin operators\n\nNow, we\u2019ll run an operation to see whether sender and owner variable are the same and will store the value in a temporary variable which we had earlier learned about in chapter 1. \n\nIn order to check whether two variable values are equal to each other, we use the following expression: \n```\nbuiltin eq i1 i2 \n```\nThis expression checks whether variable  `i1`  is equal to `i2`\nIt returns a boolean value \u2018True\u2019 or \u2018False\u2019 which can be stored in a variable. \n\nFor e.g., \n```\ntransition abc()\nempvar1 = builtin eq var1 var2\nend\n\n```\n\n\n##  Task:\n\nIn the transition \u2018deposit\u2019: \n\n1. Check whether the value of \u2018owner\u2019 and \u2018_sender\u2019 variables are the same using \u2018builtin eq\u2019 keywords. \n2. Store the result in a variable named \u2018sender_is_owner\u2019\n\n\n","\n## Lesson 4: Match\n\nBased on the previous exercise\u2019s condition, there could be two outputs: True or False. For each of these outputs there should be a different response. If the key is present then our program should prohibit user from trying to register again, but if it doesn't exist then the user should be allowed by the contract to register. This is very similar to the If-Else structure in programming. However, in Scilla we use pattern matching because of the flexibility and additional functionalities inherent in pattern matching. This pattern matching is done with the keyword `match`. Its format is as follows:\n\n```\nmatch [variablename] with\n| [pattern 1] =>\n       [statements\u2026]\n| [pattern 2] =>\n       [statements\u2026]\n| _  => (*Wild Card*)\n       [statements\u2026]\nend\n```\n\nHere variablename (without the square brackets) is the variable that we are running the test against. Based on the different values of this version, we want different code lines to be executed. After deciding the variable that we're running the checks for, we need to code the patterns that we'll be matching it against. The pattern to be matched can be a variable binding, an ADT or the wildcard symbol of underscore `(_)` which matches against anything (naturally, wild card symbol, if used, should be used last in the series of the patterns being matched or else, let's say, if it's used first then everything will match against it and the other patterns won't be used at all) Finally the end keyword declares the end of the patterns. Any variables declared in the statements for a particular match clause are valid only within that clause. Their values won't be externally recognised i.e. the scope of a variable declared within a pattern in a match condition is limited to that clause.\nAn example of a match condition is:\n\n```\nmatch check1 with\n| True  =>\n       a:=b\n| False =>\n       a:=c\nend\n```\n\nHere, if `check1` variable is true, we fix the value of the variable `a` equal to variable `b` or else if it's false, then we fix it to be equal to be variable `c`. (Assuming that variables check1, a, b and c have all been previously defined.)\n\n ##  Task:\n\nIn the transition \u2018deposit\u2019, make a \u2018match\u2019 that compares \u2018sender_is_owner\u2019 with two branches, \u2018True\u2019 and \u2018False\u2019 \n\nYou can leave the body blank for now. \n\nClose the match condition properly with \u2018end\u2019\n\n","\n## Lesson 5: Library\n\nNow, we have two conditional branches. \n\nFor each of them, a different behaviour will be programmed. Also, once the programmed action is finished, we\u2019d want to generate some kind of a message regarding that execution.\n\nFor the branch, \u2018True\u2019, which implies that sender and owner addresses are the same, we will use the \u2018accept\u2019 keyword, to accept the payment sent. \n\nBut when the condition yields \u2018False\u2019, we don\u2019t want to accept the payment, but we still want to have some action to signal that the execution of the program has finished. \n\nFor doing this, we\u2019ll be sending a message to the sender. \n\nWe\u2019ll learn more details about how to send such messages in the next chapter, but for now let\u2019s first define a code that indicates that the sender is not the owner. \n\nWe can define this code in the `library` section of our code. \n\nA library is declared in the preamble of a contract using the keyword `library` followed by the name of the library. In our current example a library declaration would look as follows:\n\n\n```\nlibrary SocialMediaPayment\n\n```\n\n\nThis library will be used to store program constants (with a scope that covers the entire contract) and also some utility functions using the `let x = y in expr` construct. We\u2019ll discuss utility functions later. \n\nFor now, we need to define a program constant (or what we\u2019ll later refer to as \u2018code\u2019) for the error message that says that the sender is not the owner. \n\nYou can see the details of syntax in the cheat sheet given at the bottom of this page. The general format for doing so is: \n\n```\nlet code_being_defined = Uint32 1\n```\n\nYou can, of course, change the variable name, variable type and the variable value as per the requirements of the contract. \n\n\n\n\n##  Task:\n\n1. Declare the library before the contract, and give it the same name as that of the contract, i.e., `SocialMediaPayment`\n\n2. In the library section, declare a `Uint32` type of variable with variable name `not_owner_code` and value `1`\n\n3. For the next chapter, we\u2019ll also need to define a code for the unsigned integer value 0. In the library section, define a `Unit128` type of variable with variable name `zero` and value `0`\n\n\n",'\n## Lesson 6: Message\n\nNow that we have defined a code that implies that the sender to deposit transition is not the owner of the smart contract, we\u2019ll have to send that code as a response. We\u2019ll do this through sending a message using the instruction send.\n\nSend is used to send messages to other accounts, either in order to invoke transitions on another smart contract, or to transfer money to user accounts. \nTo construct a message we use the following syntax:\n\n```\nmsg = {_tag : "abc"; _recipient : abc; _amount : abc; code : abc};\n```\n\nA message must contain the compulsory fields `_tag`, `_recipient` and `_amount`. The `_recipient` field is the blockchain address (of type `ByStr20`) that the message is to be sent to, and the `_amount` field is the number of ZIL to be transferred to that account.\nThe value of the `_tag` field is the name of the transition (of type `String`) that is to be invoked on the `_recipient` contract. If `_recipient` is a user account, then the value of `_tag` can be set to be `""` (the empty string). In fact, if the `_recipient` is a user account, then the value of `_tag` is ignored.\n\nIn addition to the compulsory fields the message may contain other fields, such as code above. However, if the message recipient is a contract, the additional fields must have the same names and types as the parameters of the transition being invoked on the recipient contract.\n\nSending a message is done using the `send` instruction, which takes a list of messages as a parameter. Since we currently only send one message at a time, we define a library function `one_msg` to construct a list consisting of one message:\n\n```\nlet one_msg =\n  fun (msg : Message) =>\n  let nil_msg = Nil {Message} in\n    Cons {Message} msg nil_msg\n```    \n \nTo send out a message, we first construct the message, insert it into a list, and send it:\n\n```\nmsg = {_tag : ""; _recipient : owner; _amount : bal; code : got_funds_code};\nmsgs = one_msg msg;\nsend msgs\n```\n \nThe details of this include understanding the \u2018list\u2019 functionality for Scilla. In our program, it will only be used in this one instance, so rather than going in the details, we\u2019ll simply be using the above format. However, for more details, please feel free to read it at the list section of the scilla documentation. \n\n\n##  Task:\n\n1. In the library section of the code, copy paste the following standard code: \n\n```\nlet one_msg =\n   fun (msg : Message) =>\n   let nil_msg = Nil {Message} in\n   Cons {Message} msg nil_msg\n```\n\n\n2. In the \'False\' branch of the conditions, declare a variable `msg` in the following format: \n\n```\nmsg = {_tag : "abc"; _recipient : abc; _amount : abc; code : abc};\n```\n\nWhere you will use the following values in stead of the dummy value \u2018abc\u2019 used above: \n\nFor `_tag`, value should be empty, i.e., ` ""`. \n\nFor the `_recipient`, we want to send the message to the initial sender, so the value should be: `_sender`\n\nFor the `_amount`, the value should be zero. Since we\u2019ve defined it as a `Uint128` variable in the library already, use that variable named `zero`\n\nFor the `_code`, use the code that we have defined in the library to indicate that sender is not the owner, i.e., `not_owner_code`\n\n3. Finally, after you have defined \u2018`msg`, copy the two lines below that will put this message in the list defined in the step one (i.e. `one_msg` variable type) and then send it. \n\n```\nmsgs = one_msg msg;\nsend msgs\n```\n\n\n','\n## Lesson 7: Message (2)\n\nWhile the last chapter may seem complex at first, the same format will be used again and again for sending messages, and you\u2019ll get used to the syntax pretty soon. \n\nIn fact, we\u2019ll be using the format once more in this lesson too. Now, that we\u2019ve sent a message to the user for an error in the last lesson (telling the user that the sender wallet address wasn\u2019t the same as the owner wallet address and therefore the deposit couldn\u2019t be accepted,) we\u2019ll also send a message for success. \n\nSo, this time we\u2019ll focus on the \u2018true\u2019 condition of the branch. \n\n\n\n##  Task:\n1. In the library section, declare a `Uint32` type of variable with variable name `accepted_code` and value `0`.\n\n2. Then, in the `True` branch, we have to accept the money which has been sent. So use the `accept` keyword. \n\n3. Now, in the next line declare a variable `msg` in the following format: \n```\nmsg = {_tag : "abc"; _recipient : abc; _amount : abc; code : abc};\n```\n\nWhere you will use the following values in stead of the dummy value \u2018abc\u2019 used above: \n\nFor `_tag`, value should be empty, i.e.,  `""`. \n\nFor the `_recipient`, we want to send the message to the initial sender, so the value should be: `_sender`\n\nFor the `_amount`, the value should be zero. Since we\u2019ve defined it as a `Uint128` 0 variable in the library already, use the variable name `zero`\n\nFor the `_code`, use the code that we have defined in the first step of this task to indicate that sender is  the owner, i.e., `accepted_code`\n\n4. Finally, after you have defined `msg`, copy the two lines below that will put this message in the list defined in the step one (i.e. `one_msg` variable type) and then send it. \n\n```\nmsgs = one_msg msg;\nsend msgs\n```\n\n\n\n',"\n## Congrats!\nYou've learned handling import and library sections. You've also learned working with boolean operators, conditional branches and sending response messages. \nIn the next chapter, we'll learn about maps and events. We'll also learn working with another boolean operator in Scilla and will practice sending more messages as we continue to build our Social Media Payment smart contract. \n"]},{title:"Intermediate - B",lessons:["\n## Lesson 1: Making a transition for registering users\n\nEarlier, in the first chapter, we stored user names using variables. However, there might be thousands (or millions) of users for an application. We will need a better way to store those names, than the ones we discussed in the last chapter. \n\nBefore we move towards that objective, first let\u2019s simply create a transition  which  will collect  information from the user and allow them to register. \n\n## Task\n\n 1.  After the end of the previous transition, declare a new `transition` with the name `register_user`. You can currently leave the brackets after the transition name empty. Also, make sure to end the declaration of the transition with `end` keyword. \n","\n## Lesson 2: parameters for 'register_user' transition\nWhen users will call the \u2018register_user\u2019 transition, they'll have to provide some data to the  transition so that they could be uniquely registered. \nWe\u2019ll ask the users to provide: \n\na. Their twitter id\nb. Their wallet id\n\nWe have covered this in the first chapter but for a quick reference, in case we want to declare multiple parameters for a transition, then we can do so by separating the parameter names and  types by commas, as shown below: \n\n```\ntransition transitionName (parameterName_1 : parameterType_1, parameterName_2 : parameterType_2, parameterName_3 : parameterType_3)\n  \nend\n\n```\n\n\n## Task\n In  the bracket after the transition  \u2018register_user\u2019 declare two variables: \n \n1. Declare variable \u2018user_address\u2019 of  the type `ByStr20`. This will hold the wallet address of the user. \n\n2. Declare variable \u2018twitter_username\u2019 of  the type `String`. This will hold the twitter id of the user. \n\n","\n## Lesson 3: Map- declaration\n\nNow, we want to limit the possibility of a same account creating multiple registrations.\n\nIn order to do so, we want to impose two conditions: \n\ni) Same wallet id shouldn't be able to register twice. \nii) Same twitter id shouldn\u2019t be able to register twice. \n\nIn order to impose these conditions, we\u2019ll first have to create two records, one of already registered wallet ids and second of already registered twitter ids.\n\nWe\u2019ll do so using \u2018map\u2019 feature.  \n\nA map of type `map kt vt` provides a key-value store where `kt` is the type of keys and `vt `is the type of values. `kt` may be any one of String, IntX, UintX, ByStrX or ByStr. `vt` may be any type except a function type.\n\nWe often provide the key-value `kt` as an input and look for the `vt` as the output value. For eg, `kt` could be a bank account number and `vt` could be the corresponding bank balance. \n\nThe declaration for an empty map is done as follows at the start of the contract: \n\n```\nfield a: Map FieldType1 FieldType2 = Emp FieldType1 FieldType2\n```\n\nThen the values are added to that empty map. (You can also check the other ways of declaring map in the cheat sheet.)\n\n\n\n\n\n## Task\n After the start of the contract, declare two maps with no initial values: \n\n1. A `map` with name `users` with key type `ByStr20` and value type `String`\n\n2. Then declare another `map` with name `used_usernames` with key type `String` and value type `Bool`\n \n \n","\n## Lesson 4: Map- Checking the existence of a value. \n\nIn order to check whether or not the user id or wallet id being sent by a user have been previously registered, we\u2019ll need to read the value from the map. In this particular case, we simply need to check whether such value exists or not in a given map. \n\nThe format for doing that is as follows: \n```\nb <- exists m[k]\n```\n\nThis is also called In-place existence check. It check whether in map `m`, any value corresponding to key `k` exists or not and accordingly returns a Bool which in above example is stored in variable `b`. \n\nExistence checks through nested maps is supported with the syntax `v <- exists m[k1][k2][...]`. If one or more of the intermediate key(s) do not exist in the corresponding map, the result is False.\n\n\n## Task\n\n  In the transition \u2018register_user\u2019 do the following two actions:\n\n1. Check if the value of the variable `user_address` exists in the map `users` through the keyword `exists`, and then store the value in a new variable `user_exists`. This will all be done in a single line as shown in the example above. \n\n2. Then, in the next line, check if the value of the variable `twitter_username` exists in the map `used_usernames` through the keyword `exists`, and then store the value in a new variable `username_exists`. This will all be done in a single line as shown in the example above.\n\n","\n## Lesson 5: OR operation in Scilla\n\nNow, we have two boolean values stored in the variables `user_exists` and `username_exists`.  We are interested in checking whether any of these conditions are true.  \nTo check that, we\u2019ll use the boolean operator `orb` in scilla which returns true if any of the arguments are true, or else it will return false only if both arguments are false. \nThe format for using it is: \n\n```\na = orb boolVar1 boolVar2\n```\n\nHere, `boolVar1` and `boolVar2` are two bool type variables. Using them with operator \u2018orb\u2019 returns a bool variable which is then being stored in variable `a`. \n\n\n\n\n## Task\n\n1. Use `orb` operator with the variable `user_exists` and `username_exists` and store the result in a new variable `already_exists`. This will all be done in a single line as shown in the example above.  \n","\n## Lesson 6: Using match condition\n\nWe now have `already_exists` variable. If the value of this variable is true, then we don\u2019t want to allow the user to register, however, if it\u2019s false then we do want to allow the user to register. \n\nTo implement this, we need to use a conditional structure which we learned in the previous chapter we can do through `match` keyword. \n\nFor a quick reference, the format for `match` is: \n \n ```\nmatch [variablename] with\n| [pattern 1] =>\n       [statements\u2026]\n| [pattern 2] =>\n       [statements\u2026]\n| _  => (*Wild Card*)\n       [statements\u2026]\nend\n\n```\n\n\n## Task\n\n1. Use `match` on the variable `already_exists`. \n\n2. The two branches corresponding to `match` will be `True` and `False`\n\n3. Make sure to use `end` to declare the end of the statements. \n\nWe\u2019ll fill in  the code for the individual branches over the next lessons.\n \n","\n## Lesson 7: Messages for the 'True' condition\n\n\nIn case `already_exists` variable is true, then we simply need to let the users know about that in a message. \n\nWe\u2019ll be sending that message in the same way as we did in chapter 2. \n\n## Task\n\n1. First of all, we need to define the code for such an eventuality  in the `library`. \nSo, in the library section define a variable `user_exists_code`  of `Uint32` type and value `2`\n\n2. In the 'True'  branch of the conditions, declare a variable `msg` in the following format:\n\n```\nmsg = {_tag : \"abc\"; _recipient : abc; _amount : abc; code : abc};\n```\n\nWhere you will use the following values in stead of the dummy value \u2018abc\u2019 used above:\n\nFor `_tag`, value should be empty, i.e.,  `\"\"`. \nFor the `_recipient`, we want to send the message to the initial sender, so the value should be: `_sender`\nFor the `_amount`, the value should be zero. Since we\u2019ve defined it as a `Uint128` 0 variable in the library already, use the variable name `zero`\nFor the _code, use the code that we have defined in the library to indicate that the user already exists, i.e., \u2018`user_exists_code`\n\n3. Finally, after you have defined `msg`, copy the two lines below that will put this message in the list defined in the step one (i.e. one_msg variable type) and then send it. \n\n```\nmsgs = one_msg msg;\nsend msgs\n```\n\n\n","\n## Lesson 8: Map- Adding entries\n\nAfter finishing the code in the `True` branch of the condition, let\u2019s focus on the `False` branch of the condition. \n\nThis branch implies that the user information  has  not previously existed in  the maps, so what we now have to do is to register the user by updating their information  in the maps of `users`and `used_usernames`. \n\nTo add these values, we\u2019ll be using in place insert operations that have the following format: \n\n```\nm[k] := v\n```\n\nWhere  `m` is the map variable, `k` is the key variable and  `v` is the value variable. \nInsertion into nested maps is supported with the syntax `m[k1][k2][...] := v`. If the intermediate key(s) does not exist in the nested maps, they are freshly created along with the map values they are associated with.\n\n\n\n## Task\n\n1. First, in the library section define a variable `true`  which will be equal to `True`\nHint: for boolean variables, you can do this by typing `let true =True` in the library section. See the Cheat sheet below for a quick refresher. \n\n2. Then, come to the 'False' branch in the transition. There, using the format described above, insert the value variable `twitter_username` with the corresponding key variable  `user_address` in the map `users`\n\n3. Similarly, in the next line, insert the value variable `true` with the corresponding key variable  `twitter_username` in the map `used_usernames`\n \n",'\n## Lesson 9: Event\n\nSo far, we have primarily used messages to send notifications for the users. However, there is another way of sending information back. \n\nA contract can also communicate to the outside world by emitting events.\n\nSend is used to send messages to other accounts, either in order to invoke transitions on another smart contract, or to transfer money to user accounts. On the other hand, events are dispatched signals that smart contracts can use to transmit data to client applications.\n\n An event is a signal that gets stored on the blockchain for everyone to see. If a user uses a client application to invoke a transition on a contract, the client application can listen for events that the contract may emit, and alert the user.\n\n\n`event e`: Emits a message `e` as an event. The following code emits an event with name `e_name`.\n\n```\ne = { _eventname : "e_name"; <entry>_2 ; <entry>_3 };\nevent e\n```\n\nAn emitted event must contain the compulsory field `_eventname` (of type `String`), and may contain other entries as well. The value of the `_eventname` entry must be a string literal. All events with the same name must have the same entry names and types.\n \nFor the registration confirmation, we\u2019ll be using event. \n\n\n## Task\n\n1. After the previous step of updating the map entries,  define an event `e` with  `_eventname` equal  to `register_user`.  \n\n2. For the second entry of the event, send the information about field `user` containing variable `user_address`\n\n*Hint*: the `<entry>_2 ` from the format above will look like `user: user_address` in this case. \n\n3. For the third entry of the event, send the information about field `username` containing variable `twitter_username`\n\n4. Finally, in the next line, emit the event using `event e`\n \n',"\n## Congratulations!\n\nYou've come to the end of the current content. \nMore chapters will be  updated in the future. \n\n*The full code can be seen at:*  \nhttps://github.com/AmritKumar/zil-twitter/blob/master/scilla/Twitter.scilla\n\n*The javascript code for connecting the front-end and the blockchain can be seen at:* \nhttps://github.com/AmritKumar/zil-twitter/blob/master/frontend/src/zilliqa.js\n\n*The online IDE is available at the following URL:* \nhttps://savant-ide.zilliqa.com/\n\n\n*Scilla documentation is available at the following URL:*\nhttps://scilla.readthedocs.io/en/latest/index.html\n\n\n *For any feedback, reach out to us at the channels in the footer*\n \n ##  Thanks!\n"]}],u={courseCodes:[[{initialCode:"(* Start typing from the line below. *)",answerCode:"(* Start typing from the line below. *)\nscilla_version 0\n\ncontract SocialMediaPayment"},{initialCode:"scilla_version 0\n\n(* Insert the immutable variable declaration in parantheses after the contract name below *)\ncontract SocialMediaPayment\n\n",answerCode:"scilla_version 0\n(* Insert the immutable variable declaration in parantheses after the contract name below *)\ncontract SocialMediaPayment (owner: ByStr20)"},{initialCode:"scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\n(* Start typing from the line below. *)\n",answerCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\n(* Start typing from the line below. *)\nfield username : String = "Alice"'},{initialCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = "Alice"\n\n(* Start typing from the line below *)\n',answerCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = "Alice"\n\n(* Start typing from the line below *)\ntransition changeName()\nend'},{initialCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = "Alice"\n\ntransition changeName()\n    (* Start typing from the line below *)\nend',answerCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = "Alice"\n\ntransition changeName()\n    (* Start typing from the line below *)\n    newname = "Bob"\nend'},{initialCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = "Alice"\n\ntransition changeName()\n     newname = "Bob" (*Now that we\u2019ll be having another line, don\u2019t forget to include a semicolon at the end of of the previous line, i.e. after "Bob" *)\n    (* Start typing from the line below *)\nend',answerCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = "Alice"\n\ntransition changeName()\n     newname = "Bob"; (*Now that we\u2019ll be having another line, don\u2019t forget to include a semicolon at the end of the previous line, i.e. after "Bob" *)\n    (* Start typing from the line below *)\n    username := newname\nend'},{initialCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = "Alice"\n\n\n(* Start typing in the parentheses below *)\ntransition changeName()\n   username := newname \nend\n',answerCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = "Alice"\n\n(* Start typing in the parentheses below *)\ntransition changeName(newname: String)\n    username := newname\nend'},{initialCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = "Alice"\n(*Declare the two new mutable variables below. You don\u2019t need to use any semicolons to separate the lines outside the transitions*)\n\ntransition changeName(newname: String)\n    username := newname\n    (*Use \u2018accept\u2019 command in the line below which will accept the amount sent to this transition.*)\n\n    (*Assign the value of the implicit variables to the new mutable variables in the lines below. You\u2019ll need to use the semicolons to separate the lines in the transition*)\n\nend\n',answerCode:'scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = "Alice"\nfield user_address : ByStr20 = 0x1234567890123456789012345678901234567890\nfield  user_tokens: Uint128 = Uint128 0\n\ntransition changeName(newname: String)\n    username := newname;\n    (*Use \u2018accept\u2019 command in the line below which will accept the amount sent to this transition.*)\n    accept; \n    (*Assign the value of the implicit variables to the new mutable variables in the lines below. You\u2019ll need to use the semicolons to separate the lines in the transition*)\n    user_address := _sender;\n    user_tokens := _amount\n\nend'},{initialCode:'contract Zealgame\n(owner: ByStr20)\nfield player_name : String = "Alice"\nfield player_address : ByStr20 = 0x1234567890123456789012345678901234567890\nfield player_zeal: Uint128 = Uint128 0\n\nTransition changeName(newname: String)\n    player_name := newname;\n    player_address := _sender;\n    player_zeal := _amount\nend\n',answerCode:'contract Zealgame\n(owner: ByStr20)\nfield player_name : String = "Alice"\nfield player_address : ByStr20 = 0x1234567890123456789012345678901234567890\nfield player_zeal: Uint128 = Uint128 0\n\nTransition changeName(newname: String)\n    player_name := newname;\n    player_address := _sender;\n    player_zeal := _amount\nend'}],[{initialCode:"scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\n(*Start typing from the line below*)\n",answerCode:"scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\n(*Start typing from the line below*)\n\ntransition deposit()\n\nend \n"},{initialCode:"scilla_version 0\n\n(*Start typing from the line below*)\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\n\nend\n",answerCode:"scilla_version 0\n\n(*Start typing from the line below*)\nimport BoolUtils\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\n\nend"},{initialCode:"scilla_version 0\nimport BoolUtils\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\n(*Start typing from the line below. The answer will be a single line within the transition so you won\u2019t need to use semicolon at the end*)\n\nend\n",answerCode:"scilla_version 0\n  import BoolUtils\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\n(*Start typing from the line below. The answer will be a single line within the transition so you won\u2019t need to use semicolon at the end*)\n\nsender_is_owner = builtin eq _sender owner\n\n\nend"},{initialCode:"scilla_version 0\nimport BoolUtils\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner\n(*Start typing from the line below. *)\n\nend\n",answerCode:"scilla_version 0\nimport BoolUtils\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\n(*Start typing from the line below. *)\nmatch sender_is_owner with\n     | False =>\n\n     | True =>\n\n     end\nend"},{initialCode:"scilla_version 0\nimport BoolUtils\n(*Start typing from the line below. First define the library*)\n\n(*Now define the variable zero for Uint128 0*)\n\n\n(*Now, in the line below, define the variable not_owner_code of type Uint32 and value 1*)\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n\n     | True =>\n\n     end\nend\n",answerCode:"scilla_version 0\nimport BoolUtils\n(*Start typing from the line below. First define the library*)\nlibrary SocialMediaPayment\n\n(*Now define the variable zero for Uint128 0*)\nlet zero = Uint128 0\n\n\n(*Now, in the line below, define the variable not_owner_code of type Uint32 and value 1*)\nlet not_owner_code = Uint32 1\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n\n     | True =>\n\n     end\nend"},{initialCode:"scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n(*Start typing from the line below. Copy paste the code given in the first task below to define the variable one_msg*)\n\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     (*Start typing from the line below. Define the variable msg below with the values given in the second point of the task*)\n\n\n    (*Start typing from the line below. Copy the two lines given in the third point of the task below. *)\n\n\n     | True =>\n\n     end\nend\n",answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n(*Start typing from the line below. Copy paste the code given in the first task below to define the variable one_msg*)\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     (*Start typing from the line below. Define the variable msg below with the values given in the second point of the task*)\n\n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n    (*Start typing from the line below. Copy the two lines given in the third point of the task below. *)\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n\n     end\nend\n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n(*Start typing from the line below. declare a Uint32 type of variable with variable name \u201caccepted_code\u201d and value \u201c0\u201d *)\n\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        (*Start typing from the line below for task 2, 3 and 4*)\n        \n        \n     end\nend\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n  (*Start typing from the line below. declare a Uint32 type of variable with variable name \u201caccepted_code\u201d and value \u201c0\u201d *)\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        (*Start typing from the line below for task 2, 3 and 4*)\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n(*Start typing from the line below. declare a Uint32 type of variable with variable name \u201caccepted_code\u201d and value \u201c0\u201d *)\n\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        (*Start typing from the line below for task 2, 3 and 4*)\n        \n        \n     end\nend\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n  (*Start typing from the line below. declare a Uint32 type of variable with variable name \u201caccepted_code\u201d and value \u201c0\u201d *)\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        (*Start typing from the line below for task 2, 3 and 4*)\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n  '}],[{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n(*Start typing from the line below*)\n\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n(*Start typing from the line below*)\n\ntransition register_user ()\n\n\nend\n\n  \n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n(*type within  the brackets in the line below*)\ntransition register_user ()\n\n\nend\n\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n(*type within  the brackets in the line below*)\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n\nend\n  \n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\n\n(*Start typing from the line below*)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n\nend\n  \n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n  \nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\n(*Start typing from the line below*)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n\nend\n  \n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n(*Start typing from the line below*)\n\nend\n  \n\n\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n(*Start typing from the line below*)\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username]\n\nend\n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username]\n    \n    \n    (*Start typing from the line below*)\n\n\nend\n  \n\n\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    \n    \n    (*Start typing from the line below*)\n\n    already_exists = orb user_exists username_exists\nend\n  \n  \n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists\n    \n      (*Start typing from the line below*)\n      \nend\n\n\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists;\n    \n      (*Start typing from the line below*)\n      \n      match already_exists with\n    | True =>\n    \n    | False =>\n\n\n    end\n\n      \nend\n  \n  \n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n  (*Start typing from the line below to define the variable \u2018user_exists_code\u2019 of type Uint32 and value \u20182\u2019*)\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n    (*start typing from the line below*)\n\n    | False =>\n\n\n    end\n\n      \nend\n  \n\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n  (*Start typing from the line below to define the variable \u2018user_exists_code\u2019 of type Uint32 and value \u20182\u2019*)\nlet user_exists_code = Uint32 2\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n    (*start typing from the line below*)\n     msg = {_tag: ""; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n\n\n    end\n\n      \nend \n  \n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n  \n(*Start typing from the line below definition of a boolean  variable true \u2018let true =True\u2019 *)\n  \n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: ""; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n    \n        (*start typing from the line below*)\n\n    end\n\n      \nend\n\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n\n(*Start typing from the line below definition of a boolean  variable true \u2018let true =True\u2019 *)\nlet true = True\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: ""; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n    \n        (*start typing from the line below*)\n         users[user_address] := twitter_username;\n         used_usernames[twitter_username] := true\n\n\n    end\n\n      \nend  \n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n\nlet true = True\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: ""; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n   \n      users[user_address] := twitter_username;\n      used_usernames[twitter_username] := true\n      \n       (*Start typing from the line below.  Don\u2019t forget to use a semicolon at the end of the previous line *)   \n\n    end\n\n      \nend   \n\n\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n\nlet true = True\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: ""; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n   \n      users[user_address] := twitter_username;\n      used_usernames[twitter_username] := true;\n      \n       (*Start typing from the line below.  Don\u2019t forget to use a semicolon at the end of the previous line *)  \n       \n       e = {_eventname : "register_user";\n                user: user_address;\n                username: twitter_username};\n        event e\n\n    end\n\n      \nend \n  '},{initialCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n\nlet true = True\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: ""; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n   \n      users[user_address] := twitter_username;\n      used_usernames[twitter_username] := true\n      \n       (*Start typing from the line below.  Don\u2019t forget to use a semicolon at the end of the previous line *)   \n\n    end\n\n      \nend   \n\n\n',answerCode:'scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n\nlet true = True\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: "";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: ""; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n   \n      users[user_address] := twitter_username;\n      used_usernames[twitter_username] := true;\n      \n       (*Start typing from the line below.  Don\u2019t forget to use a semicolon at the end of the previous line *)  \n       \n       e = {_eventname : "register_user";\n                user: user_address;\n                username: twitter_username};\n        event e\n\n    end\n\n      \nend \n  '}]],courseInstructions:{en:h,es:h,ja:h,ko:h,zh:h}};var g=t(45),_=Object(l.c)({course:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:u,n=arguments.length>1?arguments[1]:void 0;return n.type,e},persist:g.a}),w=(t(52),{key:"root",storage:m.a,whitelist:["persist"]}),p=Object(d.a)(w,_),b=[],y=Object(l.d)(p,l.a.apply(void 0,b)),f=Object(d.b)(y),v=t(53),S=(t(74),t(75),t(27)),x=t(40),k=t(57);x.a.init({lng:"en",debug:!1,react:{wait:!1,bindI18n:"languageChanged loaded",bindStore:"added removed",nsMode:"default"},interpolation:{escapeValue:!1},ns:["translations"],defaultNS:"translations",resources:{en:{translations:k}}});var M=x.a,T=t(18);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));r.a.render(s.a.createElement(o.a,{store:y},s.a.createElement(v.a,{loading:null,persistor:f},s.a.createElement(S.a,{i18n:M},s.a.createElement(T.a,null)))),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()}))},18:function(e,n,t){"use strict";var a=t(0),s=t.n(a),i=t(24),r=t(15),o=t(31),l=t(23),d=t(43),c=t(44),m=t(60),h=t.n(m),u=function(e){var n=e.history;return s.a.createElement("div",null,s.a.createElement(c.a,e),s.a.createElement(d.Helmet,null,s.a.createElement("title",null,"NeoPepes - Home")),s.a.createElement("section",{style:{paddingTop:180,paddingBottom:160,backgroundColor:"#162255",color:"white"}},s.a.createElement("div",{className:"container d-flex"},s.a.createElement("div",{className:"row"},s.a.createElement("div",{className:"col-xs-12 col-sm-12 col-md-12 col-lg-4"},s.a.createElement("div",{className:"my-5"},s.a.createElement("h1",{style:{marginTop:120}},s.a.createElement("b",null,"LEARN TO CODE SMART CONTRACTS ON NEO")),s.a.createElement("p",{className:"py-3"},"A step by step interactive tutorial centered around writing, deploying and interacting with Smart Contracts on the NEO blockchain"),s.a.createElement(l.Button,{className:"px-5",level:"secondary",theme:"dark",onClick:function(){return n.push(w.chapterList)},text:"Get Started"}))),s.a.createElement("div",{className:"col-xs-12 col-sm-12 col-md-12 col-lg-8"},s.a.createElement("div",null,s.a.createElement("img",{className:"img-fluid mx-auto",src:h.a,alt:"asset a",style:{marginTop:50}})))))))};t.d(n,"b",(function(){return w})),t.d(n,"a",(function(){return y}));var g=Object(a.lazy)((function(){return t.e(5).then(t.bind(null,260))})),_=Object(a.lazy)((function(){return Promise.all([t.e(2),t.e(4)]).then(t.bind(null,259))})),w={home:"/home",chapterList:"/chapters",lesson:"/chapter/:chapter/lesson/:lesson"},p=function(e){o.a.set({page:e.pathname}),o.a.pageview(e.pathname)},b=Object(r.g)((function(e){var n=e.children,t=e.history;return o.a.initialize("UA-146084454-1"),Object(a.useEffect)((function(){return p(t.location),t.listen(p)}),[t]),n})),y=function(){return s.a.createElement(i.a,null,s.a.createElement(b,null,s.a.createElement(a.Suspense,{fallback:s.a.createElement("div",{className:"text-center py-5"},s.a.createElement(l.Spinner,null))},s.a.createElement(r.d,null,s.a.createElement(r.b,{exact:!0,path:w.home,component:u}),s.a.createElement(r.b,{exact:!0,path:w.chapterList,component:g}),s.a.createElement(r.b,{exact:!0,path:w.lesson,component:_}),s.a.createElement(r.a,{from:"/",to:w.home})))))}},44:function(e,n,t){"use strict";var a=t(47),s=t(0),i=t.n(s),r=t(27),o=t(24),l=t(26),d=t(18),c=Object(r.b)()((function(e){var n=Object(s.useState)(!1),t=Object(a.a)(n,2),r=t[0],l=t[1],c=Object(s.useRef)(null);!function(e,n){var t=function(t){e.current&&!e.current.contains(t.target)&&n&&n()};Object(s.useEffect)((function(){return document.addEventListener("mousedown",t),function(){document.removeEventListener("mousedown",t)}}))}(c,(function(){return l(!1)}));var m=e.t,h=e.location.pathname;return i.a.createElement("nav",{className:"navbar navbar-expand-md navbar-dark ".concat(h===d.b.home?"fixed-top":""),style:{backgroundColor:"#162255"},ref:c},i.a.createElement(o.b,{className:"navbar-brand",to:d.b.home,"aria-label":"brand"},"NeoPepes"),i.a.createElement("button",{className:"navbar-toggler",onClick:function(){l(!r)},"aria-label":"menu"},i.a.createElement("span",{className:"navbar-toggler-icon"})),i.a.createElement("div",{"data-testid":"collapse-".concat(r?"opened":"closed"),className:"collapse ".concat(r?"show":""," navbar-collapse")},i.a.createElement("ul",{className:"ml-auto navbar-nav"},i.a.createElement("li",{className:"nav-item",style:{marginLeft:"1rem"}},i.a.createElement(o.b,{className:"nav-link ".concat(h===d.b.home?"active":""),to:d.b.home,"aria-label":"home"},m("link.home"))),i.a.createElement("li",{className:"nav-item",style:{marginLeft:"1rem"}},i.a.createElement(o.b,{className:"nav-link ".concat(h===d.b.chapterList?"active":""),to:d.b.chapterList,"aria-label":"tutorial"},m("link.tutorial"))))))}));n.a=Object(l.b)((function(e){return{ch1Progress:e.persist.ch1Progress}}),null)(c)},45:function(e,n,t){"use strict";t.d(n,"b",(function(){return s})),t.d(n,"a",(function(){return i}));var a=t(48),s=function(e){return{type:"SET_LOCAL_PROGRESS",payload:{ch1Progress:e}}};function i(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{ch1Progress:[0,0,0,0,0,0,0,0,0,0]},n=arguments.length>1?arguments[1]:void 0;switch(n.type){case"SET_LOCAL_PROGRESS":return Object(a.a)({},e,{ch1Progress:n.payload.ch1Progress});default:return e}}},57:function(e){e.exports=JSON.parse('{"chapter":{"chapter":"Chapter","goodjob":"Good Job","listTitle":"Neo Tutorial","lessonCompleteMessage":"You have completed this lesson.","chapterCompleteMessage":"You have completed this chapter."},"lesson":{"lesson":"Lesson","back":"Back","skip":"Skip","openChat":"Open Chat","nextLesson":"Proceed to Next Lesson","cheatSheet":"Cheat Sheet"},"editor":{"hint":"Hint","showHint":"Show Hint","showAnswer":"Show Answer","hideAnswer":"Hide Answer","checkAnswer":"Check Answer","tryAgain":"Try Again"},"link":{"home":"Home","tutorial":"Tutorial","tableOfContents":"Table of Contents"}}')},60:function(e,n,t){e.exports=t.p+"static/media/pepe.68760789.png"},63:function(e,n,t){e.exports=t(103)},75:function(e,n,t){}},[[63,1,3]]]);
//# sourceMappingURL=main.4c6cd375.chunk.js.map