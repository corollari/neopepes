{"version":3,"sources":["locales/instructions/en/index.ts","locales/instructions/en/chapter1/index.ts","locales/instructions/en/chapter2/index.ts","locales/instructions/en/chapter3/index.ts","redux/course/index.ts","course-codes/index.ts","course-codes/chapter1/index.ts","course-codes/chapter2/index.ts","course-codes/chapter3/index.ts","locales/instructions/index.ts","redux/rootReducer.ts","redux/store.ts","i18n.ts","serviceWorker.ts","index.tsx","containers/home-container/index.tsx","routes.tsx","components/header/index.tsx","redux/persist/index.ts","assets/images/pepe.png"],"names":["en","title","lessons","initialState","courseCodes","initialCode","answerCode","courseInstructions","es","ja","ko","zh","combineReducers","course","state","action","type","persist","persistConfig","key","storage","localStorage","whitelist","persistedReducer","persistReducer","rootReducer","middlewares","store","createStore","applyMiddleware","persistor","persistStore","i18next","init","lng","debug","process","react","wait","bindI18n","bindStore","nsMode","interpolation","escapeValue","ns","defaultNS","resources","translations","Boolean","window","location","hostname","match","ReactDOM","render","loading","i18n","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","Home","props","history","Helmet","style","paddingTop","paddingBottom","backgroundColor","color","className","marginTop","level","theme","onClick","push","paths","chapterList","text","src","A","alt","ChapterListContainer","lazy","LessonContainer","home","lesson","sendPageView","ReactGA","set","page","pathname","pageview","GoogleAnalytics","withRouter","children","initialize","useEffect","listen","RouterNode","fallback","exact","path","component","HomeContainer","from","to","withTrans","withNamespaces","useState","isTogglerOpen","setIsTogglerOpen","togglerRef","useRef","ref","callback","handleClickOutside","event","current","contains","target","addEventListener","removeEventListener","useClickOutside","t","aria-label","data-testid","marginLeft","connect","ch1Progress","setCh1Progress","payload","module","exports"],"mappings":"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","file":"static/js/main.4c6cd375.chunk.js","sourcesContent":["import { CourseInstructionType } from '../../../typings';\n\nimport chapter1 from './chapter1';\nimport chapter2 from './chapter2';\nimport chapter3 from './chapter3';\n\nconst en: CourseInstructionType = [chapter1, chapter2, chapter3];\n\nexport default en;\n","import { IChapterInstruction } from '../../../../typings';\n\nconst l1 = `\n## Introduction\n\nHello, in this guide you will learn about how to develop smart contracts and applications that use them for the NEO blockchain, we will do that by building a game of collectible pepes where users can:\n- Claim pepes\n- Trade pepes\n- Award Good Boy Points to their pepes\n\nOn this first chapter we will create our first smart contract pepe, complete with good boy point functionality. Let's start!\n\n## Lesson 1: Contract declaration\n\n**Declaring a contract:**\n\nFirst of all, currently most smart contracts on Neo are written using C#. In case you have no experience with it, don't worry! This guide assumes no previous knowledge of C# and will teach C# and smart contracts together. For now the only thing that matters is that in order to start doing smart contract magic we'll need to include some libraries from Neo:\n\n\\`\\`\\`\nusing Neo.SmartContract.Framework;\nusing Neo.SmartContract.Framework.Services.Neo;\n\\`\\`\\`\n\nNow, we can start with the main part of the smart contract coding. The contract that you’ll be deploying to the blockchain has to have a name by which it could later be identified. We will also put it inside the Neo namespace to make things easier.\nWe will do that with the following lines: \n\n\n\\`\\`\\`\nnamespace Neo.SmartContract\n{\n    public class ContractName : Framework.SmartContract\n\t{\n\t}\n}\n\\`\\`\\`\n\nWhere you replace the \\`ContractName\\` with the actual name for your contract.\n\nYou can safely ignore all the keywords such as \\`namespace\\`, \\`public\\` and \\`class\\`. These are features of C# which are not relevant here.\n\n## Task\n\n1. Begin your smart contract with the library inclusions shown above. \n2. Then, in next line, declare a contract which should be called \\`NeoPepes\\`.\n\n\n\n`;\nconst l2 = `\n## Lesson 2: Immutable variables\n\nAny contract deployed on the blockchain is immutable. In other words, that code can’t be changed. This is one of the main reasons why security of smart contracts is a fundamental concern from the very start of the coding stage, or perhaps even before that.\n\nNow, while deploying the contract on the blockchain, you can also initiate certain parameters. Once initialized, the values of these parameters won’t change, i.e. the values of these variables can’t be changed later. They are called immutable variables. \n\nFor instance, when somebody finally deploys a contract code on the blockchain, their wallet address is also passed along with the code. It’s often useful to store this address as an immutable variable because wallet addresses can serve as an identity, just like unique email addresses. But instead of sending and receiving emails, wallet addresses are primarily used for sending and receiving digital assets. You may want to store a wallet address as the address of the contract’s owner to uniquely identify the owner and grant her different access rights if required. \n\nYou can then use this immutable variable that stores the owner’s wallet address as a check, so that certain operations in the contract can only be carried out by the owner. The important part about storing the address as an immutable variable is that by doing this, the address of the owner can’t be changed by a third party. (Or else, there’s a possibility that a hacker might be able to change the owner address to her own wallet address and then act maliciously as the new owner) \n\nTo declare an immutable variable, we need to pay attention to two factors:- \n\nVariable name: This is the identifier of the variable to be used by various operators later in the contract. \n\nVariable type: Variable types represent the kind of data stored in the variable, such as text or numbers etc. We’ll discuss variable types in more detail shortly.\n\nThe format for specifying an immutable variable is: \n\n\\`\\`\\`\ncontract ContractName\n(variablename1 : variabletype1)\n\\`\\`\\`\nWhere \\`variablename1\\` and \\`variabletype1\\` can be replaced by the chosen variable name and type.\n\nFor e.g. ,\n\\`\\`\\`\ncontract  Example123 (var1 : ByStr20)\n\\`\\`\\`\n\n\nIf there are multiple immutable variables, then you can include them as follows:\n\\`\\`\\`\ncontract ContractName\n(\n    variablename1 : variabletype1,\n    variablename2 : variabletype2,\n    variablename3 : variabletype3\n)\n\\`\\`\\`\n\nFor e.g.,\n\\`\\`\\`\ncontract  Example123 (a: Uint128, b: String)\n\\`\\`\\`\n\n\nHere, multiple immutable variables are declared by separating them with commas.\nThe language supports several datatypes, such as  \\`Int32\\` (to represent 32-bit integers),\n\\`ByStr20\\` ( a sequence of hexadecimal characters that represents 20 bytes. This data type is most convenient to store wallet addresses and will be often used in smart contracts).\nA detailed list can be seen in the cheat sheet in the left bottom corner of the website. \n\nThere are many such data types in Scilla with different types of declaration and that is intentional so that later automated checks on the program can be run more easily.\n\nAs Robin Milner once said: *\"Well typed programs don’t go wrong\"*\n\nWe’ll only be introducing some of the data types through these tutorials.\nFor a detailed list of all the types, kindly refer to the 'cheat sheet' in the navigation menu above.\n\n## Task\n\nIn our last exercise, we had declared a contract called \\`SocialMediaPayment\\`. It should have one immutable variable with the name \\`owner\\` and the variable should be of type \\`ByStr20\\`.\n\n\n`;\nconst l3 = `\n## Lesson 3: Mutable variables\n\nA smart contract is not much different from a regular program. It takes certain inputs, operates on them and returns an output. Any operation may also require reading other data from the memory or storage.\n\nFor doing operations on data, we usually need to have variables whose value will be changed by the code in the contract. \n\nThese variables, which can be updated but are still stored on the blockchain are known as mutable variables. \n\nAt this point, new students often ask how you can store something mutable on an immutable blockchain. The answer is that what remains immutable is the history of how that variable’s value changed over the time. But only the latest value is actually considered by the contract to be the true value of the variable. \n\nFor e.g. , If you had USD 100 at the beginning of the month and spent USD 40 by the end of it then the bank will have a clear transaction history which you can’t change even though you can certainly change your current balance by depositing or withdrawing more money. In this example your current balance is a mutable variable but the balance-sheet itself is immutable. \n\nTo declare a mutable variable, we need to pay attention to three factors:-\nVariable name: This is the identifier of the variable to be used by various operators later in the contract.\nVariable type: Choose the appropriate type of the variable. Such as \\`Uint128\\` for amounts, String for names, \\`ByStr20\\` for addresses etc.\nVariable value: We may choose to declare a variable with or without an initial value.\n\nThe format for the mutable variable declaration might slightly vary depending on the variable type and variable value. You can access the list of the most important permutations in the variable declarations in the Cheat Sheet given in bottom left corner of this page. For now, let’s look at the format for a simple mutable variable that will contain a text/string value.\n\n\n\\`\\`\\`\nfield variableName : variableType = \"Variable Text\"\n\\`\\`\\`\n\nThe VariableType is ‘String’ in the current case. \n\nEg.\n\\`\\`\\`\nfield a : String = \"hello\"\n\\`\\`\\`\n\nThe important point to know is that in the smart contract security, changing the value of a mutable variable is a very important step and if done wrong, such a change could inadvertently result in major security vulnerabilities. We’ll see later how that issue can be handled in a methodical way in Scilla. \n\n\n## Task\n\nLet’s start with having a simple variable that stores the name of a user.\nDeclare a variable with following details:\n* Variable name: \\`username\\`\n* Variable type: \\`String\\`\n* Variable value: \\`Alice\\`\n`;\n\nconst l4 = `\n## Lesson 4: Transition\n\nThe smart contract code on blockchain needs to be able to interact with the external world for the contract to be actually useful; in other words it needs some interfaces so that the commands, data or tokens can be sent to the smart contract or be requested from it. \nThis is achieved by having transitions in the smart contract. \nTransitions are similar to ‘functions’ or ‘methods’ in other languages.\nA transition is declared using the keyword ‘transition’. The end of a transition scope is declared using the keyword ‘end’. The transition keyword is followed by the transition name. Then follows the input parameters within (). Each input parameter is separated by a comma and is declared in the following format: variablename : variabletype\n\n\nThe format is:\n\\`\\`\\`\ntransition transitionName (variablename : variabletype)\n\nend\n\\`\\`\\`\nExample:\n\\`\\`\\`\ntransition setHello (msg : String)\nend\n\\`\\`\\`\nIn order to use a smart contract, a transition within the smart contract will have to be called.\nIt can be called directly or by another program or smart contract.\n\n## Task\n\nSo far, we have a fixed value for our username variable, which is \"Alice\".\nLet’s have an option that the name could be changed. To change a mutable variable, we’ll need a transition.\n\nDeclare a transition with the name \\`changeName\\`.\nYou don’t need to pass any variables to it right now, so the brackets after the name will be empty.\n\nThere will be no code in the body of the transition at the moment.\nWe’ll fill it in later. For now, just declare an empty transition named \\`changeName\\`,\nand close it by using the keyword \\`end\\`\n`;\n\nconst l5 = `\n## Lesson 5: Variable declaration in a transition\n\nWe can also declare variables within a transition. \nDo note that these variables are not immutable variables nor are they mutable variables like the ones we learned about earlier even though the values of these variables that exist within a transition can also be changed. This is because their value is never stored on the blockchain. Rather they are temporary variables whose scope is limited within the transition for the duration of that single call. \n\nThe temporary variable declaration format is different from the format in which the mutable variables are declared. For instance, a String variable is declared in the following format:\n\\`\\`\\`\nvaribaleName = \"value\"\n\\`\\`\\`\nExample:\n\\`\\`\\`\na = \"hello\"\n\\`\\`\\`\n\n**Note:**\nIn a transition, if there are multiple lines, then they are separated by \\`semicolons\\`.\nLet’s take a look at an example of a transition with two variables declared in it:\n\nExample:\n\\`\\`\\`\ntransition foo()\n    a= \"hello\";\n    b= Int32 5\nend\n\\`\\`\\`\nIn this example, we declare two variables in a transition named \"foo\".\nThe first variable is a string type variable that stores the value hello.\nThe second variable is an integer type variable that stores the value 5.\n\nNotice two points in this example: \nThe two lines within the transition are separated by a single semicolon. We don’t use a semicolon after the declaration of the variable “b” because there are no further lines in the transition seen in the example. Those who’re familiar with other computer languages might be used to using a semicolon to end a line of code. However, here the semicolon can be thought of as being used in the capacity of a conjunction rather than a period, so just like we won’t normally use the conjunction ‘and’ at the end of a sentence, similarly we don’t use the semicolon here at the end but instead to join the various lines. \nThe format of the declaration of a string variable is different from the format of declaration of an integer variable. You can find the full list of the declaration format of all the major variable types (in the main body of the contract, and in the transition) in the ‘Cheat Sheet’ given at the bottom left corner of this page.\n\tHowever, for the sake of the exercise at the hand, you can just refer to the content provided in this lesson. \n\n\n## Task\n\nWe want to replace the original user name declared in mutable variable \\`username\\` in this transition. To do that, we will need a new name.\n\nDeclare a new variable with the name \\`newname\\` and type \\`String\\` and give it a value \\`Bob\\`.\n\n`;\nconst l6 = `\n## Lesson 6: Changing a mutable field\n\nAs stated earlier, the variable declared in the transition is a temporary variable that isn’t stored on the blockchain and exists only while the contract is being run.\nWe can use these temporary variables to get values from the user input, mutable variables etc. and then we can perform operations on these values. Then, in order to ensure that blockchain contains the final value, it has to be transferred to a mutable variable. \nYou’ll note that the design of Scilla language is making a user be very cautious about updating any value assigned to a mutable variable. That is so because changing a mutable variable is a critical operation and if done in a wrong manner, it could lead to security issues.\nWe’ll explore this in more detail in later chapters. At the moment, we simply need to assign the value of the temporary variable to the mutable variable. \nThe format of such an assignment is: \n\n\\`\\`\\`\nMutableVariableName := TemporaryVariableName\n\\`\\`\\`\nExample:\n\\`\\`\\`\nmutvar1 := tempvar1\n\\`\\`\\`\n\n## Task\n\nUpdate the mutable variable \\`username\\` with the value of the temporary variable \\`newname\\` in the body of the transition.\n\n`;\nconst l7 = `\n## Lesson 7: Getting values\n\nYou’ll notice the issue with the previous lesson that the new user is always changed to a fixed value each time that the transition is called. Ideally, we’ll like to have options other than “Bob” about the new name which is updated. This can be done by letting the user pass on a value to the transition whenever she’s calling it. \nSimilar to how we could have passed variables to the contract while creating it, we could also pass variables to a transition while calling it. \nThe format for declaring these temporary variables that have to be sent by a user when she calls the transition is as follows: \n\n\\`\\`\\`\ntransition transitionName (parameterName_1 : parameterType_1)\n\n  \nend\n\\`\\`\\`\n\n\nIn case we want to declare multiple variables here, then we can do so by separating the variable name and variable types by commas, as shown below:\n\\`\\`\\`\ntransition transitionName (parameterName_1 : parameterType_1, parameterName_2 : parameterType_2, parameterName_3 : parameterType_3)\n  \nend\n\\`\\`\\`\nExample:\n\\`\\`\\`\nTransition foo (\n    var1: String,\n    var2: Int32,\n    var3 Uint32\n)\nend\n\\`\\`\\`\n\n## Task\n\nWe want to change the name of the user ‘Alice’ that we’ve earlier stored in the mutable variable ‘username’. To do this, we created the transition ‘changeName’ and assigned a value to ‘username’. In order to make the change more flexible, we’ll also need the new name each time the transition is called. So, we’ll delete the old variable declaration in the body of the transition. Now do the following: \n \nInclude the parameter with name “newname” and variable type “String” in the declaration of the transition so that a user has to send a new name for the user each time she wishes to change the old value.  \n\n`;\nconst l8 = `\n## Lesson 8: Implicit variables\n\nIn addition to parameters that are explicitly declared in the definition, each transition also has the following implicit parameters available to it for each call:\n\\`\\`\\`\n_sender : ByStr20\n\\`\\`\\`\n\nThis variable contains the account address that triggered this transition. In case, the transition was called by a contract account instead of a user account, then _sender contains the contract address.\n\n\n\\`\\`\\`\n_amount : Uint128\n  \\`\\`\\`\n\n\nThis contains the incoming amount (ZILs) sent by the sender. This amount *must be explicitly accepted using the \\`accept\\` statement within the transition*. The money transfer does not happen if the transition does not execute accept.\n\n\n## Task\n\n1. Declare two new mutable variables in the contract:\n* \\`user_address\\` of type \\`ByStr20\\` with value \\`0x1234567890123456789012345678901234567890\\`\n* \\`user_tokens\\` of type \\`Uint128\\` with value \\`0\\` in the contract.\n\n2. Then in the transition, assign these variables the value of \\`_sender\\` and \\`_amount\\` respectively.\n\n3. Remember that the implicit variable _amount has to be explicitly accepted. Use a simple ‘accept’ command in the first line of the transition ‘changeName’. \n\nAs mentioned earlier, you can refer to the variable declaration format of all types in the ‘Cheat Sheet’ given at the bottom left corner of this page.\n`;\nconst l9 = `\n## Lesson 9: Summary\n\nChapter Number and title: Summary\nLesson contents (includes the task at the end)\nCongrats!\nYou’ve learned:\n* how to declare a new contract,\n* how to declare a new transition,\n* how to declare immutable variables,\n* how to declare mutable variables,\n* how to declare temporary variables in the transition,\n* how to use the implicit variables in a transition,\n* how to change the value of mutable variables in the transition.\n\nYou’ve learned the general structure of a contract which looks like the following:\n(* Scilla contract structure *)\n\n\\`\\`\\`\n(***************************************************)\n(*               Associated library                *)\n(***************************************************)\n\nlibrary MyContractLib\n\n\n(* Library code block follows *)\n\n\n\n(***************************************************)\n(*             Contract definition                 *)\n(***************************************************)\n\ncontract MyContract\n\n(* Immutable fields declaration *)\n\n(vname_1 : vtype_1, vname_2 : vtype_2)\n\n(* Mutable fields declaration *)\n\nfield vname_1 : vtype_1 = init_val_1\nfield vname_2 : vtype_2 = init_val_2\n\n(* Transitions *)\n\n(* Transition signature *)\ntransition firstTransition (\n    param_1 : type_1,\n    param_2 : type_2\n)\n    (* Transition body *)\nend\n\ntransition secondTransition (param_1: type_1)\n    (* Transition body *)\nend\n\\`\\`\\`\n\nYou’ve defined a user which has certain attributes such as name, address and tokens.\n\n\n`;\n\nconst chapter1: IChapterInstruction = {\n  title: 'Elementary',\n  lessons: [l1, l2, l3, l4, l5, l6, l7, l8, l9]\n};\n\nexport default chapter1;\n","import { IChapterInstruction } from '../../../../typings';\n\nconst l1 = `\n## Lesson 1: Making a transition for depositing tokens\n\nIn the last chapter, we learned about various kinds of variables, including implicit variable. \nLet’s build a transition that actually uses that. \nWe’ll first wipe the variables from the first chapter, and from now onwards all the code that we’ll be using will help us directly build the social media payment application that we discussed. \n\nFirst of all, in order to give ZIL tokens as rewards, the contract must have access to them. \nIn order to ensure that, we need to build a transition where the ZIL tokens can be deposited in the contract. \n\n\n\n## Task\n\n 1. Declare a \\`transition\\` with the name 'deposit’. Make sure to close it with \\`end\\` keyword.\n\n`;\n\nconst l2 = `\n## Lesson 2: Boolean operations\n\nNow, we’ve to ensure that this transition can accept any amount of ZILs sent to it. We’ve already seen how to do this at the end of chapter 1. \nWe can simply repeat that process here and technically that’s fine. \nHowever, for any actual application, you probably want to ensure that not everybody can send tokens to this transition. Can you think of a reason why you would deny getting an additional amount? \nWell, for one thing, it will make your auditing really difficult if you don’t have a clear track of who’s sending the tokens to your contract. Also, it’s generally a good coding practice to manage access to transitions in a controlled manner. \nSo, we’ll program this transition so that only the owner can send money to it. \n\nWe’ve two variables: \\`owner\\` which is an immutable variable and will always remain constant and \\`_sender\\` which is an implicit variable and contains the wallet address of the user who has invoked the transition for that operation. We need to have a condition that ensures that deposit happens only when the two variables’s values are the same. \n\nTo do this, we’ll need to use comparison operators which are available in Scilla. These operators check whether the given comparison (such as, is a= b, or is a>b, or is a <b)  is true or false, and accordingly return a boolean (i.e. a value that is ‘true’ or ‘false’) value. \n\nIn order to process these boolean values, we will need to include a boolean library in our code. \n\nYou can do this by using import function for any library. \nThe format for that is:\n\n\\`\\`\\`\nimport LibraryName\n\\`\\`\\`\n\nE.g., \n\\`\\`\\`\nimport ListUtils\n\\`\\`\\`\n\nIf there are multiple libraries, then you can simply include more libraries by providing a space between their names after the keyword import\n\n\\`\\`\\`\nimport LibraryName1 LibraryName2\n\\`\\`\\`\n\nE.g.,\n\\`\\`\\`\nimport ListUtils IntUtils\n\\`\\`\\`\n\n\n\nNote: You have to use ‘import’  before the contract declaration. \n\n\nYou can find the complete list of libraries here: https://scilla.readthedocs.io/en/latest/scilla-in-depth.html?highlight=boolutils#standard-libraries\n\n\nFor now, we only need to include one library: BoolUtils\n\n\n\n\n## Task\n\n After the scilla version declaration and before the contract declaration, do the following:\n \n 1. Import the following library: \\`BoolUtils\\`. Use the keyword \\`import\\` to do so. \n\n\n`;\n\nconst l3 = `\n## Lesson 3: Builtin operators\n\nNow, we’ll run an operation to see whether sender and owner variable are the same and will store the value in a temporary variable which we had earlier learned about in chapter 1. \n\nIn order to check whether two variable values are equal to each other, we use the following expression: \n\\`\\`\\`\nbuiltin eq i1 i2 \n\\`\\`\\`\nThis expression checks whether variable  \\`i1\\`  is equal to \\`i2\\`\nIt returns a boolean value ‘True’ or ‘False’ which can be stored in a variable. \n\nFor e.g., \n\\`\\`\\`\ntransition abc()\nempvar1 = builtin eq var1 var2\nend\n\n\\`\\`\\`\n\n\n##  Task:\n\nIn the transition ‘deposit’: \n\n1. Check whether the value of ‘owner’ and ‘_sender’ variables are the same using ‘builtin eq’ keywords. \n2. Store the result in a variable named ‘sender_is_owner’\n\n\n`;\n\nconst l4 = `\n## Lesson 4: Match\n\nBased on the previous exercise’s condition, there could be two outputs: True or False. For each of these outputs there should be a different response. If the key is present then our program should prohibit user from trying to register again, but if it doesn't exist then the user should be allowed by the contract to register. This is very similar to the If-Else structure in programming. However, in Scilla we use pattern matching because of the flexibility and additional functionalities inherent in pattern matching. This pattern matching is done with the keyword \\`match\\`. Its format is as follows:\n\n\\`\\`\\`\nmatch [variablename] with\n| [pattern 1] =>\n       [statements…]\n| [pattern 2] =>\n       [statements…]\n| _  => (*Wild Card*)\n       [statements…]\nend\n\\`\\`\\`\n\nHere variablename (without the square brackets) is the variable that we are running the test against. Based on the different values of this version, we want different code lines to be executed. After deciding the variable that we're running the checks for, we need to code the patterns that we'll be matching it against. The pattern to be matched can be a variable binding, an ADT or the wildcard symbol of underscore \\`(_)\\` which matches against anything (naturally, wild card symbol, if used, should be used last in the series of the patterns being matched or else, let's say, if it's used first then everything will match against it and the other patterns won't be used at all) Finally the end keyword declares the end of the patterns. Any variables declared in the statements for a particular match clause are valid only within that clause. Their values won't be externally recognised i.e. the scope of a variable declared within a pattern in a match condition is limited to that clause.\nAn example of a match condition is:\n\n\\`\\`\\`\nmatch check1 with\n| True  =>\n       a:=b\n| False =>\n       a:=c\nend\n\\`\\`\\`\n\nHere, if \\`check1\\` variable is true, we fix the value of the variable \\`a\\` equal to variable \\`b\\` or else if it's false, then we fix it to be equal to be variable \\`c\\`. (Assuming that variables check1, a, b and c have all been previously defined.)\n\n ##  Task:\n\nIn the transition ‘deposit’, make a ‘match’ that compares ‘sender_is_owner’ with two branches, ‘True’ and ‘False’ \n\nYou can leave the body blank for now. \n\nClose the match condition properly with ‘end’\n\n`;\n\nconst l5 = `\n## Lesson 5: Library\n\nNow, we have two conditional branches. \n\nFor each of them, a different behaviour will be programmed. Also, once the programmed action is finished, we’d want to generate some kind of a message regarding that execution.\n\nFor the branch, ‘True’, which implies that sender and owner addresses are the same, we will use the ‘accept’ keyword, to accept the payment sent. \n\nBut when the condition yields ‘False’, we don’t want to accept the payment, but we still want to have some action to signal that the execution of the program has finished. \n\nFor doing this, we’ll be sending a message to the sender. \n\nWe’ll learn more details about how to send such messages in the next chapter, but for now let’s first define a code that indicates that the sender is not the owner. \n\nWe can define this code in the \\`library\\` section of our code. \n\nA library is declared in the preamble of a contract using the keyword \\`library\\` followed by the name of the library. In our current example a library declaration would look as follows:\n\n\n\\`\\`\\`\nlibrary SocialMediaPayment\n\n\\`\\`\\`\n\n\nThis library will be used to store program constants (with a scope that covers the entire contract) and also some utility functions using the \\`let x = y in expr\\` construct. We’ll discuss utility functions later. \n\nFor now, we need to define a program constant (or what we’ll later refer to as ‘code’) for the error message that says that the sender is not the owner. \n\nYou can see the details of syntax in the cheat sheet given at the bottom of this page. The general format for doing so is: \n\n\\`\\`\\`\nlet code_being_defined = Uint32 1\n\\`\\`\\`\n\nYou can, of course, change the variable name, variable type and the variable value as per the requirements of the contract. \n\n\n\n\n##  Task:\n\n1. Declare the library before the contract, and give it the same name as that of the contract, i.e., \\`SocialMediaPayment\\`\n\n2. In the library section, declare a \\`Uint32\\` type of variable with variable name \\`not_owner_code\\` and value \\`1\\`\n\n3. For the next chapter, we’ll also need to define a code for the unsigned integer value 0. In the library section, define a \\`Unit128\\` type of variable with variable name \\`zero\\` and value \\`0\\`\n\n\n`;\n\nconst l6 = `\n## Lesson 6: Message\n\nNow that we have defined a code that implies that the sender to deposit transition is not the owner of the smart contract, we’ll have to send that code as a response. We’ll do this through sending a message using the instruction send.\n\nSend is used to send messages to other accounts, either in order to invoke transitions on another smart contract, or to transfer money to user accounts. \nTo construct a message we use the following syntax:\n\n\\`\\`\\`\nmsg = {_tag : \"abc\"; _recipient : abc; _amount : abc; code : abc};\n\\`\\`\\`\n\nA message must contain the compulsory fields \\`_tag\\`, \\`_recipient\\` and \\`_amount\\`. The \\`_recipient\\` field is the blockchain address (of type \\`ByStr20\\`) that the message is to be sent to, and the \\`_amount\\` field is the number of ZIL to be transferred to that account.\nThe value of the \\`_tag\\` field is the name of the transition (of type \\`String\\`) that is to be invoked on the \\`_recipient\\` contract. If \\`_recipient\\` is a user account, then the value of \\`_tag\\` can be set to be \\`\"\"\\` (the empty string). In fact, if the \\`_recipient\\` is a user account, then the value of \\`_tag\\` is ignored.\n\nIn addition to the compulsory fields the message may contain other fields, such as code above. However, if the message recipient is a contract, the additional fields must have the same names and types as the parameters of the transition being invoked on the recipient contract.\n\nSending a message is done using the \\`send\\` instruction, which takes a list of messages as a parameter. Since we currently only send one message at a time, we define a library function \\`one_msg\\` to construct a list consisting of one message:\n\n\\`\\`\\`\nlet one_msg =\n  fun (msg : Message) =>\n  let nil_msg = Nil {Message} in\n    Cons {Message} msg nil_msg\n\\`\\`\\`    \n \nTo send out a message, we first construct the message, insert it into a list, and send it:\n\n\\`\\`\\`\nmsg = {_tag : \"\"; _recipient : owner; _amount : bal; code : got_funds_code};\nmsgs = one_msg msg;\nsend msgs\n\\`\\`\\`\n \nThe details of this include understanding the ‘list’ functionality for Scilla. In our program, it will only be used in this one instance, so rather than going in the details, we’ll simply be using the above format. However, for more details, please feel free to read it at the list section of the scilla documentation. \n\n\n##  Task:\n\n1. In the library section of the code, copy paste the following standard code: \n\n\\`\\`\\`\nlet one_msg =\n   fun (msg : Message) =>\n   let nil_msg = Nil {Message} in\n   Cons {Message} msg nil_msg\n\\`\\`\\`\n\n\n2. In the 'False' branch of the conditions, declare a variable \\`msg\\` in the following format: \n\n\\`\\`\\`\nmsg = {_tag : \"abc\"; _recipient : abc; _amount : abc; code : abc};\n\\`\\`\\`\n\nWhere you will use the following values in stead of the dummy value ‘abc’ used above: \n\nFor \\`_tag\\`, value should be empty, i.e., \\` \"\"\\`. \n\nFor the \\`_recipient\\`, we want to send the message to the initial sender, so the value should be: \\`_sender\\`\n\nFor the \\`_amount\\`, the value should be zero. Since we’ve defined it as a \\`Uint128\\` variable in the library already, use that variable named \\`zero\\`\n\nFor the \\`_code\\`, use the code that we have defined in the library to indicate that sender is not the owner, i.e., \\`not_owner_code\\`\n\n3. Finally, after you have defined ‘\\`msg\\`, copy the two lines below that will put this message in the list defined in the step one (i.e. \\`one_msg\\` variable type) and then send it. \n\n\\`\\`\\`\nmsgs = one_msg msg;\nsend msgs\n\\`\\`\\`\n\n\n`;\n\nconst l7 = `\n## Lesson 7: Message (2)\n\nWhile the last chapter may seem complex at first, the same format will be used again and again for sending messages, and you’ll get used to the syntax pretty soon. \n\nIn fact, we’ll be using the format once more in this lesson too. Now, that we’ve sent a message to the user for an error in the last lesson (telling the user that the sender wallet address wasn’t the same as the owner wallet address and therefore the deposit couldn’t be accepted,) we’ll also send a message for success. \n\nSo, this time we’ll focus on the ‘true’ condition of the branch. \n\n\n\n##  Task:\n1. In the library section, declare a \\`Uint32\\` type of variable with variable name \\`accepted_code\\` and value \\`0\\`.\n\n2. Then, in the \\`True\\` branch, we have to accept the money which has been sent. So use the \\`accept\\` keyword. \n\n3. Now, in the next line declare a variable \\`msg\\` in the following format: \n\\`\\`\\`\nmsg = {_tag : \"abc\"; _recipient : abc; _amount : abc; code : abc};\n\\`\\`\\`\n\nWhere you will use the following values in stead of the dummy value ‘abc’ used above: \n\nFor \\`_tag\\`, value should be empty, i.e.,  \\`\"\"\\`. \n\nFor the \\`_recipient\\`, we want to send the message to the initial sender, so the value should be: \\`_sender\\`\n\nFor the \\`_amount\\`, the value should be zero. Since we’ve defined it as a \\`Uint128\\` 0 variable in the library already, use the variable name \\`zero\\`\n\nFor the \\`_code\\`, use the code that we have defined in the first step of this task to indicate that sender is  the owner, i.e., \\`accepted_code\\`\n\n4. Finally, after you have defined \\`msg\\`, copy the two lines below that will put this message in the list defined in the step one (i.e. \\`one_msg\\` variable type) and then send it. \n\n\\`\\`\\`\nmsgs = one_msg msg;\nsend msgs\n\\`\\`\\`\n\n\n\n`;\n\nconst l8 = `\n## Congrats!\nYou've learned handling import and library sections. You've also learned working with boolean operators, conditional branches and sending response messages. \nIn the next chapter, we'll learn about maps and events. We'll also learn working with another boolean operator in Scilla and will practice sending more messages as we continue to build our Social Media Payment smart contract. \n`;\n\nconst chapter2: IChapterInstruction = {\n  title: 'Intermediate - A',\n  lessons: [l1, l2, l3, l4, l5, l6, l7, l8]\n};\n\nexport default chapter2;\n","import { IChapterInstruction } from '../../../../typings';\n\nconst l1 = `\n## Lesson 1: Making a transition for registering users\n\nEarlier, in the first chapter, we stored user names using variables. However, there might be thousands (or millions) of users for an application. We will need a better way to store those names, than the ones we discussed in the last chapter. \n\nBefore we move towards that objective, first let’s simply create a transition  which  will collect  information from the user and allow them to register. \n\n## Task\n\n 1.  After the end of the previous transition, declare a new \\`transition\\` with the name \\`register_user\\`. You can currently leave the brackets after the transition name empty. Also, make sure to end the declaration of the transition with \\`end\\` keyword. \n`;\n\nconst l2 = `\n## Lesson 2: parameters for 'register_user' transition\nWhen users will call the ‘register_user’ transition, they'll have to provide some data to the  transition so that they could be uniquely registered. \nWe’ll ask the users to provide: \n\na. Their twitter id\nb. Their wallet id\n\nWe have covered this in the first chapter but for a quick reference, in case we want to declare multiple parameters for a transition, then we can do so by separating the parameter names and  types by commas, as shown below: \n\n\\`\\`\\`\ntransition transitionName (parameterName_1 : parameterType_1, parameterName_2 : parameterType_2, parameterName_3 : parameterType_3)\n  \nend\n\n\\`\\`\\`\n\n\n## Task\n In  the bracket after the transition  ‘register_user’ declare two variables: \n \n1. Declare variable ‘user_address’ of  the type \\`ByStr20\\`. This will hold the wallet address of the user. \n\n2. Declare variable ‘twitter_username’ of  the type \\`String\\`. This will hold the twitter id of the user. \n\n`;\n\nconst l3 = `\n## Lesson 3: Map- declaration\n\nNow, we want to limit the possibility of a same account creating multiple registrations.\n\nIn order to do so, we want to impose two conditions: \n\ni) Same wallet id shouldn't be able to register twice. \nii) Same twitter id shouldn’t be able to register twice. \n\nIn order to impose these conditions, we’ll first have to create two records, one of already registered wallet ids and second of already registered twitter ids.\n\nWe’ll do so using ‘map’ feature.  \n\nA map of type \\`map kt vt\\` provides a key-value store where \\`kt\\` is the type of keys and \\`vt \\`is the type of values. \\`kt\\` may be any one of String, IntX, UintX, ByStrX or ByStr. \\`vt\\` may be any type except a function type.\n\nWe often provide the key-value \\`kt\\` as an input and look for the \\`vt\\` as the output value. For eg, \\`kt\\` could be a bank account number and \\`vt\\` could be the corresponding bank balance. \n\nThe declaration for an empty map is done as follows at the start of the contract: \n\n\\`\\`\\`\nfield a: Map FieldType1 FieldType2 = Emp FieldType1 FieldType2\n\\`\\`\\`\n\nThen the values are added to that empty map. (You can also check the other ways of declaring map in the cheat sheet.)\n\n\n\n\n\n## Task\n After the start of the contract, declare two maps with no initial values: \n\n1. A \\`map\\` with name \\`users\\` with key type \\`ByStr20\\` and value type \\`String\\`\n\n2. Then declare another \\`map\\` with name \\`used_usernames\\` with key type \\`String\\` and value type \\`Bool\\`\n \n \n`;\n\nconst l4 = `\n## Lesson 4: Map- Checking the existence of a value. \n\nIn order to check whether or not the user id or wallet id being sent by a user have been previously registered, we’ll need to read the value from the map. In this particular case, we simply need to check whether such value exists or not in a given map. \n\nThe format for doing that is as follows: \n\\`\\`\\`\nb <- exists m[k]\n\\`\\`\\`\n\nThis is also called In-place existence check. It check whether in map \\`m\\`, any value corresponding to key \\`k\\` exists or not and accordingly returns a Bool which in above example is stored in variable \\`b\\`. \n\nExistence checks through nested maps is supported with the syntax \\`v <- exists m[k1][k2][...]\\`. If one or more of the intermediate key(s) do not exist in the corresponding map, the result is False.\n\n\n## Task\n\n  In the transition ‘register_user’ do the following two actions:\n\n1. Check if the value of the variable \\`user_address\\` exists in the map \\`users\\` through the keyword \\`exists\\`, and then store the value in a new variable \\`user_exists\\`. This will all be done in a single line as shown in the example above. \n\n2. Then, in the next line, check if the value of the variable \\`twitter_username\\` exists in the map \\`used_usernames\\` through the keyword \\`exists\\`, and then store the value in a new variable \\`username_exists\\`. This will all be done in a single line as shown in the example above.\n\n`;\n\nconst l5 = `\n## Lesson 5: OR operation in Scilla\n\nNow, we have two boolean values stored in the variables \\`user_exists\\` and \\`username_exists\\`.  We are interested in checking whether any of these conditions are true.  \nTo check that, we’ll use the boolean operator \\`orb\\` in scilla which returns true if any of the arguments are true, or else it will return false only if both arguments are false. \nThe format for using it is: \n\n\\`\\`\\`\na = orb boolVar1 boolVar2\n\\`\\`\\`\n\nHere, \\`boolVar1\\` and \\`boolVar2\\` are two bool type variables. Using them with operator ‘orb’ returns a bool variable which is then being stored in variable \\`a\\`. \n\n\n\n\n## Task\n\n1. Use \\`orb\\` operator with the variable \\`user_exists\\` and \\`username_exists\\` and store the result in a new variable \\`already_exists\\`. This will all be done in a single line as shown in the example above.  \n`;\n\nconst l6 = `\n## Lesson 6: Using match condition\n\nWe now have \\`already_exists\\` variable. If the value of this variable is true, then we don’t want to allow the user to register, however, if it’s false then we do want to allow the user to register. \n\nTo implement this, we need to use a conditional structure which we learned in the previous chapter we can do through \\`match\\` keyword. \n\nFor a quick reference, the format for \\`match\\` is: \n \n \\`\\`\\`\nmatch [variablename] with\n| [pattern 1] =>\n       [statements…]\n| [pattern 2] =>\n       [statements…]\n| _  => (*Wild Card*)\n       [statements…]\nend\n\n\\`\\`\\`\n\n\n## Task\n\n1. Use \\`match\\` on the variable \\`already_exists\\`. \n\n2. The two branches corresponding to \\`match\\` will be \\`True\\` and \\`False\\`\n\n3. Make sure to use \\`end\\` to declare the end of the statements. \n\nWe’ll fill in  the code for the individual branches over the next lessons.\n \n`;\n\nconst l7 = `\n## Lesson 7: Messages for the 'True' condition\n\n\nIn case \\`already_exists\\` variable is true, then we simply need to let the users know about that in a message. \n\nWe’ll be sending that message in the same way as we did in chapter 2. \n\n## Task\n\n1. First of all, we need to define the code for such an eventuality  in the \\`library\\`. \nSo, in the library section define a variable \\`user_exists_code\\`  of \\`Uint32\\` type and value \\`2\\`\n\n2. In the 'True'  branch of the conditions, declare a variable \\`msg\\` in the following format:\n\n\\`\\`\\`\nmsg = {_tag : \"abc\"; _recipient : abc; _amount : abc; code : abc};\n\\`\\`\\`\n\nWhere you will use the following values in stead of the dummy value ‘abc’ used above:\n\nFor \\`_tag\\`, value should be empty, i.e.,  \\`\"\"\\`. \nFor the \\`_recipient\\`, we want to send the message to the initial sender, so the value should be: \\`_sender\\`\nFor the \\`_amount\\`, the value should be zero. Since we’ve defined it as a \\`Uint128\\` 0 variable in the library already, use the variable name \\`zero\\`\nFor the _code, use the code that we have defined in the library to indicate that the user already exists, i.e., ‘\\`user_exists_code\\`\n\n3. Finally, after you have defined \\`msg\\`, copy the two lines below that will put this message in the list defined in the step one (i.e. one_msg variable type) and then send it. \n\n\\`\\`\\`\nmsgs = one_msg msg;\nsend msgs\n\\`\\`\\`\n\n\n`;\n\nconst l8 = `\n## Lesson 8: Map- Adding entries\n\nAfter finishing the code in the \\`True\\` branch of the condition, let’s focus on the \\`False\\` branch of the condition. \n\nThis branch implies that the user information  has  not previously existed in  the maps, so what we now have to do is to register the user by updating their information  in the maps of \\`users\\`and \\`used_usernames\\`. \n\nTo add these values, we’ll be using in place insert operations that have the following format: \n\n\\`\\`\\`\nm[k] := v\n\\`\\`\\`\n\nWhere  \\`m\\` is the map variable, \\`k\\` is the key variable and  \\`v\\` is the value variable. \nInsertion into nested maps is supported with the syntax \\`m[k1][k2][...] := v\\`. If the intermediate key(s) does not exist in the nested maps, they are freshly created along with the map values they are associated with.\n\n\n\n## Task\n\n1. First, in the library section define a variable \\`true\\`  which will be equal to \\`True\\`\nHint: for boolean variables, you can do this by typing \\`let true =True\\` in the library section. See the Cheat sheet below for a quick refresher. \n\n2. Then, come to the 'False' branch in the transition. There, using the format described above, insert the value variable \\`twitter_username\\` with the corresponding key variable  \\`user_address\\` in the map \\`users\\`\n\n3. Similarly, in the next line, insert the value variable \\`true\\` with the corresponding key variable  \\`twitter_username\\` in the map \\`used_usernames\\`\n \n`;\n\nconst l9 = `\n## Lesson 9: Event\n\nSo far, we have primarily used messages to send notifications for the users. However, there is another way of sending information back. \n\nA contract can also communicate to the outside world by emitting events.\n\nSend is used to send messages to other accounts, either in order to invoke transitions on another smart contract, or to transfer money to user accounts. On the other hand, events are dispatched signals that smart contracts can use to transmit data to client applications.\n\n An event is a signal that gets stored on the blockchain for everyone to see. If a user uses a client application to invoke a transition on a contract, the client application can listen for events that the contract may emit, and alert the user.\n\n\n\\`event e\\`: Emits a message \\`e\\` as an event. The following code emits an event with name \\`e_name\\`.\n\n\\`\\`\\`\ne = { _eventname : \"e_name\"; <entry>_2 ; <entry>_3 };\nevent e\n\\`\\`\\`\n\nAn emitted event must contain the compulsory field \\`_eventname\\` (of type \\`String\\`), and may contain other entries as well. The value of the \\`_eventname\\` entry must be a string literal. All events with the same name must have the same entry names and types.\n \nFor the registration confirmation, we’ll be using event. \n\n\n## Task\n\n1. After the previous step of updating the map entries,  define an event \\`e\\` with  \\`_eventname\\` equal  to \\`register_user\\`.  \n\n2. For the second entry of the event, send the information about field \\`user\\` containing variable \\`user_address\\`\n\n*Hint*: the \\`<entry>_2 \\` from the format above will look like \\`user: user_address\\` in this case. \n\n3. For the third entry of the event, send the information about field \\`username\\` containing variable \\`twitter_username\\`\n\n4. Finally, in the next line, emit the event using \\`event e\\`\n \n`;\n\nconst l10 = `\n## Congratulations!\n\nYou've come to the end of the current content. \nMore chapters will be  updated in the future. \n\n*The full code can be seen at:*  \nhttps://github.com/AmritKumar/zil-twitter/blob/master/scilla/Twitter.scilla\n\n*The javascript code for connecting the front-end and the blockchain can be seen at:* \nhttps://github.com/AmritKumar/zil-twitter/blob/master/frontend/src/zilliqa.js\n\n*The online IDE is available at the following URL:* \nhttps://savant-ide.zilliqa.com/\n\n\n*Scilla documentation is available at the following URL:*\nhttps://scilla.readthedocs.io/en/latest/index.html\n\n\n *For any feedback, reach out to us at the channels in the footer*\n \n ##  Thanks!\n`;\n\nconst chapter3: IChapterInstruction = {\n  title: 'Intermediate - B',\n  lessons: [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10]\n};\n\nexport default chapter3;\n","import courseInstructions from '../../locales/instructions';\nimport courseCodes from '../../course-codes';\n\nconst initialState = { courseCodes, courseInstructions };\n\nexport default function courseReducer(state = initialState, action) {\n  switch (action.type) {\n    default:\n      return state;\n  }\n}\n","import { CourseCodeType } from '../typings';\nimport chapter1 from './chapter1';\nimport chapter2 from './chapter2';\nimport chapter3 from './chapter3';\n\nconst course: CourseCodeType = [chapter1, chapter2, chapter3];\n\nexport default course;\n","import { ILessonCode, ChapterCodeType } from '../../typings';\n\nconst l1: ILessonCode = {\n  initialCode: `(* Start typing from the line below. *)`,\n  answerCode: `(* Start typing from the line below. *)\nscilla_version 0\n\ncontract SocialMediaPayment`\n};\n\nconst l2: ILessonCode = {\n  initialCode: `scilla_version 0\n\n(* Insert the immutable variable declaration in parantheses after the contract name below *)\ncontract SocialMediaPayment\n\n`,\n  answerCode: `scilla_version 0\n(* Insert the immutable variable declaration in parantheses after the contract name below *)\ncontract SocialMediaPayment (owner: ByStr20)`\n};\n\nconst l3: ILessonCode = {\n  initialCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\n(* Start typing from the line below. *)\n`,\n  answerCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\n(* Start typing from the line below. *)\nfield username : String = \"Alice\"`\n};\n\nconst l4: ILessonCode = {\n  initialCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = \"Alice\"\n\n(* Start typing from the line below *)\n`,\n  answerCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = \"Alice\"\n\n(* Start typing from the line below *)\ntransition changeName()\nend`\n};\n\nconst l5: ILessonCode = {\n  initialCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = \"Alice\"\n\ntransition changeName()\n    (* Start typing from the line below *)\nend`,\n  answerCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = \"Alice\"\n\ntransition changeName()\n    (* Start typing from the line below *)\n    newname = \"Bob\"\nend`\n};\n\nconst l6: ILessonCode = {\n  initialCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = \"Alice\"\n\ntransition changeName()\n     newname = \"Bob\" (*Now that we’ll be having another line, don’t forget to include a semicolon at the end of of the previous line, i.e. after \"Bob\" *)\n    (* Start typing from the line below *)\nend`,\n  answerCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = \"Alice\"\n\ntransition changeName()\n     newname = \"Bob\"; (*Now that we’ll be having another line, don’t forget to include a semicolon at the end of the previous line, i.e. after \"Bob\" *)\n    (* Start typing from the line below *)\n    username := newname\nend`\n};\n\nconst l7: ILessonCode = {\n  initialCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = \"Alice\"\n\n\n(* Start typing in the parentheses below *)\ntransition changeName()\n   username := newname \nend\n`,\n  answerCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = \"Alice\"\n\n(* Start typing in the parentheses below *)\ntransition changeName(newname: String)\n    username := newname\nend`\n};\n\nconst l8: ILessonCode = {\n  initialCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = \"Alice\"\n(*Declare the two new mutable variables below. You don’t need to use any semicolons to separate the lines outside the transitions*)\n\ntransition changeName(newname: String)\n    username := newname\n    (*Use ‘accept’ command in the line below which will accept the amount sent to this transition.*)\n\n    (*Assign the value of the implicit variables to the new mutable variables in the lines below. You’ll need to use the semicolons to separate the lines in the transition*)\n\nend\n`,\n  answerCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\nfield username : String = \"Alice\"\nfield user_address : ByStr20 = 0x1234567890123456789012345678901234567890\nfield  user_tokens: Uint128 = Uint128 0\n\ntransition changeName(newname: String)\n    username := newname;\n    (*Use ‘accept’ command in the line below which will accept the amount sent to this transition.*)\n    accept; \n    (*Assign the value of the implicit variables to the new mutable variables in the lines below. You’ll need to use the semicolons to separate the lines in the transition*)\n    user_address := _sender;\n    user_tokens := _amount\n\nend`\n};\n\nconst l9: ILessonCode = {\n  initialCode: `contract Zealgame\n(owner: ByStr20)\nfield player_name : String = \"Alice\"\nfield player_address : ByStr20 = 0x1234567890123456789012345678901234567890\nfield player_zeal: Uint128 = Uint128 0\n\nTransition changeName(newname: String)\n    player_name := newname;\n    player_address := _sender;\n    player_zeal := _amount\nend\n`,\n  answerCode: `contract Zealgame\n(owner: ByStr20)\nfield player_name : String = \"Alice\"\nfield player_address : ByStr20 = 0x1234567890123456789012345678901234567890\nfield player_zeal: Uint128 = Uint128 0\n\nTransition changeName(newname: String)\n    player_name := newname;\n    player_address := _sender;\n    player_zeal := _amount\nend`\n};\n\nconst chapter1: ChapterCodeType = [l1, l2, l3, l4, l5, l6, l7, l8, l9];\n\nexport default chapter1;\n","import { ILessonCode, ChapterCodeType } from '../../typings';\n\nconst l1: ILessonCode = {\n  initialCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\n(*Start typing from the line below*)\n`,\n  answerCode: `scilla_version 0\n\ncontract SocialMediaPayment (owner: ByStr20)\n(*Start typing from the line below*)\n\ntransition deposit()\n\nend \n`\n};\n\nconst l2: ILessonCode = {\n  initialCode: `scilla_version 0\n\n(*Start typing from the line below*)\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\n\nend\n`,\n  answerCode: `scilla_version 0\n\n(*Start typing from the line below*)\nimport BoolUtils\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\n\nend`\n};\n\nconst l3: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\n(*Start typing from the line below. The answer will be a single line within the transition so you won’t need to use semicolon at the end*)\n\nend\n`,\n  answerCode: `scilla_version 0\n  import BoolUtils\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\n(*Start typing from the line below. The answer will be a single line within the transition so you won’t need to use semicolon at the end*)\n\nsender_is_owner = builtin eq _sender owner\n\n\nend`\n};\n\nconst l4: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner\n(*Start typing from the line below. *)\n\nend\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\n(*Start typing from the line below. *)\nmatch sender_is_owner with\n     | False =>\n\n     | True =>\n\n     end\nend`\n};\n\nconst l5: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n(*Start typing from the line below. First define the library*)\n\n(*Now define the variable zero for Uint128 0*)\n\n\n(*Now, in the line below, define the variable not_owner_code of type Uint32 and value 1*)\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n\n     | True =>\n\n     end\nend\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n(*Start typing from the line below. First define the library*)\nlibrary SocialMediaPayment\n\n(*Now define the variable zero for Uint128 0*)\nlet zero = Uint128 0\n\n\n(*Now, in the line below, define the variable not_owner_code of type Uint32 and value 1*)\nlet not_owner_code = Uint32 1\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n\n     | True =>\n\n     end\nend`\n};\n\nconst l6: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n(*Start typing from the line below. Copy paste the code given in the first task below to define the variable one_msg*)\n\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     (*Start typing from the line below. Define the variable msg below with the values given in the second point of the task*)\n\n\n    (*Start typing from the line below. Copy the two lines given in the third point of the task below. *)\n\n\n     | True =>\n\n     end\nend\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n(*Start typing from the line below. Copy paste the code given in the first task below to define the variable one_msg*)\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     (*Start typing from the line below. Define the variable msg below with the values given in the second point of the task*)\n\n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n    (*Start typing from the line below. Copy the two lines given in the third point of the task below. *)\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n\n     end\nend\n  `\n};\n\nconst l7: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n(*Start typing from the line below. declare a Uint32 type of variable with variable name “accepted_code” and value “0” *)\n\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        (*Start typing from the line below for task 2, 3 and 4*)\n        \n        \n     end\nend\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n  (*Start typing from the line below. declare a Uint32 type of variable with variable name “accepted_code” and value “0” *)\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        (*Start typing from the line below for task 2, 3 and 4*)\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n  `\n};\n\nconst l8: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n(*Start typing from the line below. declare a Uint32 type of variable with variable name “accepted_code” and value “0” *)\n\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        (*Start typing from the line below for task 2, 3 and 4*)\n        \n        \n     end\nend\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\n  (*Start typing from the line below. declare a Uint32 type of variable with variable name “accepted_code” and value “0” *)\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        (*Start typing from the line below for task 2, 3 and 4*)\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n  `\n};\n\nconst chapter2: ChapterCodeType = [l1, l2, l3, l4, l5, l6, l7, l8];\n\nexport default chapter2;\n","import { ILessonCode, ChapterCodeType } from '../../typings';\n\nconst l1: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n(*Start typing from the line below*)\n\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n(*Start typing from the line below*)\n\ntransition register_user ()\n\n\nend\n\n  \n  `\n};\n\nconst l2: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n(*type within  the brackets in the line below*)\ntransition register_user ()\n\n\nend\n\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n(*type within  the brackets in the line below*)\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n\nend\n  \n  `\n};\n\nconst l3: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\n\n(*Start typing from the line below*)\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n\nend\n  \n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n  \nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\n(*Start typing from the line below*)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n\nend\n  \n  `\n};\n\nconst l4: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n(*Start typing from the line below*)\n\nend\n  \n\n\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n(*Start typing from the line below*)\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username]\n\nend\n  `\n};\n\nconst l5: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username]\n    \n    \n    (*Start typing from the line below*)\n\n\nend\n  \n\n\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    \n    \n    (*Start typing from the line below*)\n\n    already_exists = orb user_exists username_exists\nend\n  \n  \n  `\n};\n\nconst l6: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists\n    \n      (*Start typing from the line below*)\n      \nend\n\n\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists;\n    \n      (*Start typing from the line below*)\n      \n      match already_exists with\n    | True =>\n    \n    | False =>\n\n\n    end\n\n      \nend\n  \n  \n  `\n};\n\nconst l7: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n  (*Start typing from the line below to define the variable ‘user_exists_code’ of type Uint32 and value ‘2’*)\n\ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n    (*start typing from the line below*)\n\n    | False =>\n\n\n    end\n\n      \nend\n  \n\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\n  (*Start typing from the line below to define the variable ‘user_exists_code’ of type Uint32 and value ‘2’*)\nlet user_exists_code = Uint32 2\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n    (*start typing from the line below*)\n     msg = {_tag: \"\"; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n\n\n    end\n\n      \nend \n  \n  `\n};\n\nconst l8: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n  \n(*Start typing from the line below definition of a boolean  variable true ‘let true =True’ *)\n  \n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: \"\"; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n    \n        (*start typing from the line below*)\n\n    end\n\n      \nend\n\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n\n(*Start typing from the line below definition of a boolean  variable true ‘let true =True’ *)\nlet true = True\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: \"\"; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n    \n        (*start typing from the line below*)\n         users[user_address] := twitter_username;\n         used_usernames[twitter_username] := true\n\n\n    end\n\n      \nend  \n  `\n};\n\nconst l9: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n\nlet true = True\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: \"\"; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n   \n      users[user_address] := twitter_username;\n      used_usernames[twitter_username] := true\n      \n       (*Start typing from the line below.  Don’t forget to use a semicolon at the end of the previous line *)   \n\n    end\n\n      \nend   \n\n\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n\nlet true = True\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: \"\"; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n   \n      users[user_address] := twitter_username;\n      used_usernames[twitter_username] := true;\n      \n       (*Start typing from the line below.  Don’t forget to use a semicolon at the end of the previous line *)  \n       \n       e = {_eventname : \"register_user\";\n                user: user_address;\n                username: twitter_username};\n        event e\n\n    end\n\n      \nend \n  `\n};\n\nconst l10: ILessonCode = {\n  initialCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n\nlet true = True\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: \"\"; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n   \n      users[user_address] := twitter_username;\n      used_usernames[twitter_username] := true\n      \n       (*Start typing from the line below.  Don’t forget to use a semicolon at the end of the previous line *)   \n\n    end\n\n      \nend   \n\n\n`,\n  answerCode: `scilla_version 0\nimport BoolUtils\n\nlibrary SocialMediaPayment\n\nlet one_msg = \n  fun (msg : Message) => \n  let nil_msg = Nil {Message} in\n  Cons {Message} msg nil_msg\n\nlet zero = Uint128 0\nlet not_owner_code = Uint32 1\nlet accepted_code = Uint32 0\nlet user_exists_code = Uint32 2\n\nlet true = True\n  \ncontract SocialMediaPayment(owner: ByStr20)\n\nfield users: Map ByStr20 String\n    = Emp ByStr20 String\n\nfield used_usernames: Map String Bool\n    = Emp String Bool\n\ntransition deposit()\nsender_is_owner = builtin eq _sender owner;\nmatch sender_is_owner with\n     | False =>\n     \n          msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: not_owner_code};\n          msgs = one_msg msg;\n          send msgs\n\n     | True =>\n        accept;\n        msg = {_tag: \"\";\n                _recipient: _sender;\n                _amount: zero;\n                code: accepted_code};\n        msgs = one_msg msg;\n        send msgs\n        \n     end\nend\n\n\ntransition register_user (user_address: ByStr20, twitter_username: String)\n\n    user_exists <- exists users[user_address];\n    username_exists <- exists used_usernames[twitter_username];\n    already_exists = orb user_exists username_exists ;     \n    match already_exists with\n    | True =>\n    \n     msg = {_tag: \"\"; _recipient: _sender; _amount: zero; code: user_exists_code};\n     msgs = one_msg msg;\n     send msgs\n\n\n    | False =>\n   \n      users[user_address] := twitter_username;\n      used_usernames[twitter_username] := true;\n      \n       (*Start typing from the line below.  Don’t forget to use a semicolon at the end of the previous line *)  \n       \n       e = {_eventname : \"register_user\";\n                user: user_address;\n                username: twitter_username};\n        event e\n\n    end\n\n      \nend \n  `\n};\n\nconst chapter3: ChapterCodeType = [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10];\n\nexport default chapter3;\n","import en from './en';\n\nexport default {\n  en,\n  es: en,\n  ja: en,\n  ko: en,\n  zh: en\n};\n","import { combineReducers } from 'redux';\n\nimport course from './course';\nimport persist from './persist';\n\nexport default combineReducers({\n  course,\n  persist\n});\n","import { createStore, applyMiddleware } from 'redux';\nimport { persistStore, persistReducer } from 'redux-persist';\nimport localStorage from 'redux-persist/lib/storage'; // defaults to localStorage for web and AsyncStorage for react-native\n\nimport rootReducer from './rootReducer';\nimport { logger } from 'redux-logger';\n\nconst persistConfig = {\n  key: 'root',\n  storage: localStorage,\n  whitelist: ['persist']\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\n// Use redux logger only when env is development\nconst isDev = process.env.NODE_ENV === 'development';\nconst middlewares = isDev ? [logger] : [];\n\nexport const store = createStore(\n  // reducer\n  persistedReducer,\n  // enhancer\n  applyMiddleware(...middlewares)\n);\n\nexport const persistor = persistStore(store);\n","import i18next from 'i18next';\n\nimport en from './locales/ui/en.json';\n\nexport const langDictionary = {\n  en: 'English [en]'\n};\n\nconst isDev: boolean = process.env.NODE_ENV === 'development';\n\ni18next.init({\n  lng: 'en',\n  debug: isDev,\n  react: {\n    wait: false,\n    bindI18n: 'languageChanged loaded',\n    bindStore: 'added removed',\n    nsMode: 'default'\n  },\n  interpolation: { escapeValue: false }, // not needed for react\n  // lowerCaseLng: true,\n  // have a common namespace used around the full app\n  ns: ['translations'],\n  defaultNS: 'translations',\n\n  resources: {\n    en: { translations: en }\n  }\n});\n\nexport default i18next;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { store, persistor } from './redux/store';\nimport { PersistGate } from 'redux-persist/integration/react';\n\n// Put any other imports below so that CSS from your\n// components takes precedence over default styles.\nimport 'bootstrap/dist/css/bootstrap.css';\nimport './index.css';\n\nimport { I18nextProvider } from 'react-i18next';\nimport i18n from './i18n';\nimport { RouterNode } from './routes';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate loading={null} persistor={persistor}>\n      <I18nextProvider i18n={i18n}>\n        <RouterNode />\n      </I18nextProvider>\n    </PersistGate>\n  </Provider>,\n  document.getElementById('root') as HTMLElement\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React from 'react';\nimport { Helmet } from 'react-helmet';\nimport Header from '../../components/header';\nimport { Button } from 'react-fn-components';\nimport { paths } from '../../routes';\nimport A from '../../assets/images/pepe.png';\n\nconst Home = (props) => {\n  const { history } = props;\n  const documentTitle = `NeoPepes - Home`;\n  return (\n    <div>\n      <Header {...props} />\n      <Helmet>\n        <title>{documentTitle}</title>\n      </Helmet>\n\n      <section\n        style={{\n          paddingTop: 180,\n          paddingBottom: 160,\n          backgroundColor: '#162255',\n          color: 'white'\n        }}\n      >\n        <div className=\"container d-flex\">\n          <div className=\"row\">\n            <div className=\"col-xs-12 col-sm-12 col-md-12 col-lg-4\">\n              <div className=\"my-5\">\n                <h1 style={{ marginTop: 120 }}>\n                  <b>LEARN TO CODE SMART CONTRACTS ON NEO</b>\n                </h1>\n\n                <p className=\"py-3\">A step by step interactive tutorial centered around writing, deploying and interacting with Smart Contracts on the NEO blockchain</p>\n                <Button\n                  className=\"px-5\"\n                  level=\"secondary\"\n                  theme=\"dark\"\n                  onClick={() => history.push(paths.chapterList)}\n                  text=\"Get Started\"\n                />\n              </div>\n            </div>\n            <div className=\"col-xs-12 col-sm-12 col-md-12 col-lg-8\">\n              <div>\n                <img\n                  className=\"img-fluid mx-auto\"\n                  src={A}\n                  alt=\"asset a\"\n                  style={{ marginTop: 50 }}\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </section>\n    </div>\n  );\n};\n\nexport default Home;\n","// @ts-ignore\nimport React, { Suspense, lazy, useEffect } from 'react';\n\nimport { BrowserRouter, Route, Switch, Redirect } from 'react-router-dom';\nimport { withRouter } from 'react-router';\n\nimport ReactGA from 'react-ga';\n\nimport { Spinner } from 'react-fn-components';\nimport HomeContainer from './containers/home-container';\nconst ChapterListContainer = lazy(() => import('./containers/chapter-list-container'));\nconst LessonContainer = lazy(() => import('./containers/lesson-container'));\n\nexport const paths = {\n  home: '/home',\n  chapterList: '/chapters',\n  lesson: '/chapter/:chapter/lesson/:lesson'\n};\n\nconst sendPageView = (location) => {\n  ReactGA.set({ page: location.pathname });\n  ReactGA.pageview(location.pathname);\n};\n\nconst GAListener = (props) => {\n  const { children, history } = props;\n  const GA_KEY = 'UA-146084454-1';\n  ReactGA.initialize(GA_KEY);\n  useEffect(() => {\n    sendPageView(history.location);\n    return history.listen(sendPageView);\n  }, [history]);\n\n  return children;\n};\n\nconst GoogleAnalytics = withRouter(GAListener);\n\nexport const RouterNode: React.SFC = () => (\n  <BrowserRouter>\n    <GoogleAnalytics>\n      <Suspense\n        fallback={\n          <div className=\"text-center py-5\">\n            <Spinner />\n          </div>\n        }\n      >\n        <Switch>\n          <Route exact={true} path={paths.home} component={HomeContainer} />\n          <Route exact={true} path={paths.chapterList} component={ChapterListContainer} />\n          <Route exact={true} path={paths.lesson} component={LessonContainer} />\n          <Redirect from=\"/\" to={paths.home} />\n        </Switch>\n      </Suspense>\n    </GoogleAnalytics>\n  </BrowserRouter>\n);\n","import React, { useState, useEffect, useRef } from 'react';\nimport { withNamespaces } from 'react-i18next';\nimport { Link } from 'react-router-dom';\nimport { connect } from 'react-redux';\nimport { paths } from '../../routes';\n\nconst useClickOutside = (ref, callback) => {\n  const handleClickOutside = (event) => {\n    if (ref.current && !ref.current.contains(event.target) && callback) {\n      callback();\n    }\n  };\n\n  useEffect(() => {\n    // Bind the event listener\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => {\n      // Unbind the event listener on clean up\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  });\n};\n\nconst Header = (props) => {\n  const [isTogglerOpen, setIsTogglerOpen] = useState(false);\n  const togglerRef = useRef(null);\n\n  useClickOutside(togglerRef, () => setIsTogglerOpen(false));\n\n  const { t, location } = props;\n  const { pathname } = location;\n\n  const toggle = () => {\n    setIsTogglerOpen(!isTogglerOpen);\n  };\n\n  return (\n    <nav\n      className={`navbar navbar-expand-md navbar-dark ${\n        pathname === paths.home ? 'fixed-top' : ''\n      }`}\n      style={{ backgroundColor: '#162255' }}\n      ref={togglerRef}\n    >\n      <Link className=\"navbar-brand\" to={paths.home} aria-label={'brand'}>\n        {'NeoPepes'}\n      </Link>\n\n      <button className=\"navbar-toggler\" onClick={toggle} aria-label={'menu'}>\n        <span className=\"navbar-toggler-icon\" />\n      </button>\n\n      <div\n        data-testid={`collapse-${isTogglerOpen ? 'opened' : 'closed'}`}\n        className={`collapse ${isTogglerOpen ? 'show' : ''} navbar-collapse`}\n      >\n        <ul className=\"ml-auto navbar-nav\">\n          <li className=\"nav-item\" style={{ marginLeft: '1rem' }}>\n            <Link\n              className={`nav-link ${pathname === paths.home ? 'active' : ''}`}\n              to={paths.home}\n              aria-label={'home'}\n            >\n              {t('link.home')}\n            </Link>\n          </li>\n\n          <li className=\"nav-item\" style={{ marginLeft: '1rem' }}>\n            <Link\n              className={`nav-link ${pathname === paths.chapterList ? 'active' : ''}`}\n              to={paths.chapterList}\n              aria-label={'tutorial'}\n            >\n              {t('link.tutorial')}\n            </Link>\n          </li>\n        </ul>\n      </div>\n    </nav>\n  );\n};\n\n// @ts-ignore\nconst withTrans = withNamespaces()(Header);\n\nconst mapStateToProps = (state) => ({\n  ch1Progress: state.persist.ch1Progress\n});\n\nexport default connect(\n  mapStateToProps,\n  null\n)(withTrans);\n","export const SET_CH1_PROGRESS: string = 'SET_LOCAL_PROGRESS';\nexport const setCh1Progress = (ch1Progress) => ({\n  type: SET_CH1_PROGRESS,\n  payload: { ch1Progress }\n});\n\nexport default function persistReducer(\n  state = { ch1Progress: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] },\n  action\n) {\n  switch (action.type) {\n    case SET_CH1_PROGRESS:\n      return {\n        ...state,\n        ch1Progress: action.payload.ch1Progress\n      };\n    default:\n      return state;\n  }\n}\n","module.exports = __webpack_public_path__ + \"static/media/pepe.68760789.png\";"],"sourceRoot":""}